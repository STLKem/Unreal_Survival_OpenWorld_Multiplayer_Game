// Copyright Epic Games, Inc. All Rights Reserved.
/*===========================================================================
	Generated code exported from UnrealHeaderTool.
	DO NOT modify this manually! Edit the corresponding .h files instead!
===========================================================================*/

#include "UObject/GeneratedCppIncludes.h"
#include "VoxelGraph/Public/VoxelNodes/VoxelMathNodes.h"

PRAGMA_DISABLE_DEPRECATION_WARNINGS

void EmptyLinkFunctionForGeneratedCodeVoxelMathNodes() {}

// ********** Begin Cross Module References ********************************************************
UPackage* Z_Construct_UPackage__Script_VoxelGraph();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_1MinusX();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_1MinusX_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Acos();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Acos_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Asin();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Asin_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Atan();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Atan2();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Atan2_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Atan_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_BAnd();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_BAnd_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_BNot();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_BNot_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_BOr();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_BOr_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_BreakColorFloat();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_BreakColorFloat_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_BreakColorInt();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_BreakColorInt_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Ceil();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Ceil_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Clamp();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Clamp_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Cos();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Cos_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Exp();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Exp_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_FAbs();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_FAbs_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_FAdd();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_FAdd_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_FDivide();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_FDivide_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_FloatOfInt();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_FloatOfInt_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Floor();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Floor_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_FMax();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_FMax_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_FMin();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_FMin_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_FMod();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_FMod_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_FMultiply();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_FMultiply_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Fraction();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Fraction_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_FSign();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_FSign_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_FSubstract();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_FSubstract_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_HSVToRGB();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_HSVToRGB_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_IAbs();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_IAbs_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_IAdd();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_IAdd_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_IDivide();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_IDivide_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_ILeftBitShift();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_ILeftBitShift_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_IMax();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_IMax_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_IMin();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_IMin_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_IMod();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_IMod_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_IMultiply();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_IMultiply_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_InverseTransformPositionXZ();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_InverseTransformPositionXZ_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_InvSqrt();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_InvSqrt_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_IRightBitShift();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_IRightBitShift_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_ISign();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_ISign_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_ISubstract();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_ISubstract_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Lerp();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Lerp_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Loge();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Loge_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_MakeColorFloat();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_MakeColorFloat_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_MakeColorInt();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_MakeColorInt_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_MinusX();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_MinusX_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_NormalizeSum();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_NormalizeSum_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_OneOverX();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_OneOverX_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Pi();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Pi_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Pow();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Pow_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_RGBToHSV();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_RGBToHSV_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Round();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Round_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_SafeLerp();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_SafeLerp_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Sin();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Sin_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_SinCos();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_SinCos_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Sinh();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Sinh_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_SmoothStep();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_SmoothStep_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Sqrt();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Sqrt_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_SwitchColor();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_SwitchColor_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_SwitchFloat();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_SwitchFloat_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_SwitchInt();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_SwitchInt_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Tan();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_Tan_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_VectorLength();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_VectorLength_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_VectorRotateAngleAxis();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNode_VectorRotateAngleAxis_NoRegister();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelNodeHelper();
VOXELGRAPH_API UClass* Z_Construct_UClass_UVoxelPureNode();
// ********** End Cross Module References **********************************************************

// ********** Begin Class UVoxelNode_FMax **********************************************************
void UVoxelNode_FMax::StaticRegisterNativesUVoxelNode_FMax()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_FMax;
UClass* UVoxelNode_FMax::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_FMax;
	if (!Z_Registration_Info_UClass_UVoxelNode_FMax.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_FMax"),
			Z_Registration_Info_UClass_UVoxelNode_FMax.InnerSingleton,
			StaticRegisterNativesUVoxelNode_FMax,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_FMax.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_FMax_NoRegister()
{
	return UVoxelNode_FMax::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_FMax_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Max\n" },
		{ "DisplayName", "Max (float)" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Max" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_FMax>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_FMax_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_FMax_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_FMax_Statics::ClassParams = {
	&UVoxelNode_FMax::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_FMax_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_FMax_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_FMax()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_FMax.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_FMax.OuterSingleton, Z_Construct_UClass_UVoxelNode_FMax_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_FMax.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_FMax);
UVoxelNode_FMax::~UVoxelNode_FMax() {}
// ********** End Class UVoxelNode_FMax ************************************************************

// ********** Begin Class UVoxelNode_FMin **********************************************************
void UVoxelNode_FMin::StaticRegisterNativesUVoxelNode_FMin()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_FMin;
UClass* UVoxelNode_FMin::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_FMin;
	if (!Z_Registration_Info_UClass_UVoxelNode_FMin.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_FMin"),
			Z_Registration_Info_UClass_UVoxelNode_FMin.InnerSingleton,
			StaticRegisterNativesUVoxelNode_FMin,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_FMin.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_FMin_NoRegister()
{
	return UVoxelNode_FMin::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_FMin_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Min\n" },
		{ "DisplayName", "Min (float)" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Min" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_FMin>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_FMin_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_FMin_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_FMin_Statics::ClassParams = {
	&UVoxelNode_FMin::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_FMin_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_FMin_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_FMin()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_FMin.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_FMin.OuterSingleton, Z_Construct_UClass_UVoxelNode_FMin_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_FMin.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_FMin);
UVoxelNode_FMin::~UVoxelNode_FMin() {}
// ********** End Class UVoxelNode_FMin ************************************************************

// ********** Begin Class UVoxelNode_IMax **********************************************************
void UVoxelNode_IMax::StaticRegisterNativesUVoxelNode_IMax()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_IMax;
UClass* UVoxelNode_IMax::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_IMax;
	if (!Z_Registration_Info_UClass_UVoxelNode_IMax.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_IMax"),
			Z_Registration_Info_UClass_UVoxelNode_IMax.InnerSingleton,
			StaticRegisterNativesUVoxelNode_IMax,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_IMax.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_IMax_NoRegister()
{
	return UVoxelNode_IMax::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_IMax_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Integer" },
		{ "Comment", "// Max\n" },
		{ "DisplayName", "Max (int)" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Max" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_IMax>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_IMax_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_IMax_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_IMax_Statics::ClassParams = {
	&UVoxelNode_IMax::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_IMax_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_IMax_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_IMax()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_IMax.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_IMax.OuterSingleton, Z_Construct_UClass_UVoxelNode_IMax_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_IMax.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_IMax);
UVoxelNode_IMax::~UVoxelNode_IMax() {}
// ********** End Class UVoxelNode_IMax ************************************************************

// ********** Begin Class UVoxelNode_IMin **********************************************************
void UVoxelNode_IMin::StaticRegisterNativesUVoxelNode_IMin()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_IMin;
UClass* UVoxelNode_IMin::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_IMin;
	if (!Z_Registration_Info_UClass_UVoxelNode_IMin.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_IMin"),
			Z_Registration_Info_UClass_UVoxelNode_IMin.InnerSingleton,
			StaticRegisterNativesUVoxelNode_IMin,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_IMin.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_IMin_NoRegister()
{
	return UVoxelNode_IMin::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_IMin_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Integer" },
		{ "Comment", "// Min\n" },
		{ "DisplayName", "Min (int)" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Min" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_IMin>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_IMin_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_IMin_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_IMin_Statics::ClassParams = {
	&UVoxelNode_IMin::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_IMin_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_IMin_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_IMin()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_IMin.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_IMin.OuterSingleton, Z_Construct_UClass_UVoxelNode_IMin_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_IMin.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_IMin);
UVoxelNode_IMin::~UVoxelNode_IMin() {}
// ********** End Class UVoxelNode_IMin ************************************************************

// ********** Begin Class UVoxelNode_FAdd **********************************************************
void UVoxelNode_FAdd::StaticRegisterNativesUVoxelNode_FAdd()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_FAdd;
UClass* UVoxelNode_FAdd::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_FAdd;
	if (!Z_Registration_Info_UClass_UVoxelNode_FAdd.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_FAdd"),
			Z_Registration_Info_UClass_UVoxelNode_FAdd.InnerSingleton,
			StaticRegisterNativesUVoxelNode_FAdd,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_FAdd.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_FAdd_NoRegister()
{
	return UVoxelNode_FAdd::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_FAdd_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Add\n" },
		{ "DisplayName", "float + float" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "Keywords", "+ add plus" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Add" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_FAdd>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_FAdd_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_FAdd_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_FAdd_Statics::ClassParams = {
	&UVoxelNode_FAdd::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_FAdd_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_FAdd_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_FAdd()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_FAdd.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_FAdd.OuterSingleton, Z_Construct_UClass_UVoxelNode_FAdd_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_FAdd.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_FAdd);
UVoxelNode_FAdd::~UVoxelNode_FAdd() {}
// ********** End Class UVoxelNode_FAdd ************************************************************

// ********** Begin Class UVoxelNode_FMultiply *****************************************************
void UVoxelNode_FMultiply::StaticRegisterNativesUVoxelNode_FMultiply()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_FMultiply;
UClass* UVoxelNode_FMultiply::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_FMultiply;
	if (!Z_Registration_Info_UClass_UVoxelNode_FMultiply.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_FMultiply"),
			Z_Registration_Info_UClass_UVoxelNode_FMultiply.InnerSingleton,
			StaticRegisterNativesUVoxelNode_FMultiply,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_FMultiply.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_FMultiply_NoRegister()
{
	return UVoxelNode_FMultiply::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_FMultiply_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Multiply\n" },
		{ "DisplayName", "float * float" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "Keywords", "* multiply" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Multiply" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_FMultiply>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_FMultiply_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_FMultiply_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_FMultiply_Statics::ClassParams = {
	&UVoxelNode_FMultiply::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_FMultiply_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_FMultiply_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_FMultiply()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_FMultiply.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_FMultiply.OuterSingleton, Z_Construct_UClass_UVoxelNode_FMultiply_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_FMultiply.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_FMultiply);
UVoxelNode_FMultiply::~UVoxelNode_FMultiply() {}
// ********** End Class UVoxelNode_FMultiply *******************************************************

// ********** Begin Class UVoxelNode_FSubstract ****************************************************
void UVoxelNode_FSubstract::StaticRegisterNativesUVoxelNode_FSubstract()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_FSubstract;
UClass* UVoxelNode_FSubstract::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_FSubstract;
	if (!Z_Registration_Info_UClass_UVoxelNode_FSubstract.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_FSubstract"),
			Z_Registration_Info_UClass_UVoxelNode_FSubstract.InnerSingleton,
			StaticRegisterNativesUVoxelNode_FSubstract,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_FSubstract.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_FSubstract_NoRegister()
{
	return UVoxelNode_FSubstract::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_FSubstract_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Subtract\n" },
		{ "DisplayName", "float - float" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "Keywords", "- subtract minus" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Subtract" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_FSubstract>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_FSubstract_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_FSubstract_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_FSubstract_Statics::ClassParams = {
	&UVoxelNode_FSubstract::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_FSubstract_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_FSubstract_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_FSubstract()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_FSubstract.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_FSubstract.OuterSingleton, Z_Construct_UClass_UVoxelNode_FSubstract_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_FSubstract.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_FSubstract);
UVoxelNode_FSubstract::~UVoxelNode_FSubstract() {}
// ********** End Class UVoxelNode_FSubstract ******************************************************

// ********** Begin Class UVoxelNode_FDivide *******************************************************
void UVoxelNode_FDivide::StaticRegisterNativesUVoxelNode_FDivide()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_FDivide;
UClass* UVoxelNode_FDivide::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_FDivide;
	if (!Z_Registration_Info_UClass_UVoxelNode_FDivide.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_FDivide"),
			Z_Registration_Info_UClass_UVoxelNode_FDivide.InnerSingleton,
			StaticRegisterNativesUVoxelNode_FDivide,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_FDivide.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_FDivide_NoRegister()
{
	return UVoxelNode_FDivide::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_FDivide_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Divide\n" },
		{ "DisplayName", "float / float" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "Keywords", "/ divide division" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Divide" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_FDivide>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_FDivide_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_FDivide_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_FDivide_Statics::ClassParams = {
	&UVoxelNode_FDivide::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_FDivide_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_FDivide_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_FDivide()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_FDivide.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_FDivide.OuterSingleton, Z_Construct_UClass_UVoxelNode_FDivide_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_FDivide.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_FDivide);
UVoxelNode_FDivide::~UVoxelNode_FDivide() {}
// ********** End Class UVoxelNode_FDivide *********************************************************

// ********** Begin Class UVoxelNode_IAdd **********************************************************
void UVoxelNode_IAdd::StaticRegisterNativesUVoxelNode_IAdd()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_IAdd;
UClass* UVoxelNode_IAdd::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_IAdd;
	if (!Z_Registration_Info_UClass_UVoxelNode_IAdd.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_IAdd"),
			Z_Registration_Info_UClass_UVoxelNode_IAdd.InnerSingleton,
			StaticRegisterNativesUVoxelNode_IAdd,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_IAdd.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_IAdd_NoRegister()
{
	return UVoxelNode_IAdd::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_IAdd_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Integer" },
		{ "Comment", "// Add\n" },
		{ "DisplayName", "int + int" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "Keywords", "+ add plus" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Add" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_IAdd>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_IAdd_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_IAdd_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_IAdd_Statics::ClassParams = {
	&UVoxelNode_IAdd::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_IAdd_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_IAdd_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_IAdd()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_IAdd.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_IAdd.OuterSingleton, Z_Construct_UClass_UVoxelNode_IAdd_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_IAdd.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_IAdd);
UVoxelNode_IAdd::~UVoxelNode_IAdd() {}
// ********** End Class UVoxelNode_IAdd ************************************************************

// ********** Begin Class UVoxelNode_IMultiply *****************************************************
void UVoxelNode_IMultiply::StaticRegisterNativesUVoxelNode_IMultiply()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_IMultiply;
UClass* UVoxelNode_IMultiply::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_IMultiply;
	if (!Z_Registration_Info_UClass_UVoxelNode_IMultiply.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_IMultiply"),
			Z_Registration_Info_UClass_UVoxelNode_IMultiply.InnerSingleton,
			StaticRegisterNativesUVoxelNode_IMultiply,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_IMultiply.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_IMultiply_NoRegister()
{
	return UVoxelNode_IMultiply::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_IMultiply_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Integer" },
		{ "Comment", "// Multiply\n" },
		{ "DisplayName", "int * int" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "Keywords", "* multiply" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Multiply" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_IMultiply>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_IMultiply_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_IMultiply_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_IMultiply_Statics::ClassParams = {
	&UVoxelNode_IMultiply::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_IMultiply_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_IMultiply_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_IMultiply()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_IMultiply.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_IMultiply.OuterSingleton, Z_Construct_UClass_UVoxelNode_IMultiply_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_IMultiply.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_IMultiply);
UVoxelNode_IMultiply::~UVoxelNode_IMultiply() {}
// ********** End Class UVoxelNode_IMultiply *******************************************************

// ********** Begin Class UVoxelNode_ISubstract ****************************************************
void UVoxelNode_ISubstract::StaticRegisterNativesUVoxelNode_ISubstract()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_ISubstract;
UClass* UVoxelNode_ISubstract::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_ISubstract;
	if (!Z_Registration_Info_UClass_UVoxelNode_ISubstract.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_ISubstract"),
			Z_Registration_Info_UClass_UVoxelNode_ISubstract.InnerSingleton,
			StaticRegisterNativesUVoxelNode_ISubstract,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_ISubstract.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_ISubstract_NoRegister()
{
	return UVoxelNode_ISubstract::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_ISubstract_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Integer" },
		{ "Comment", "// Subtract\n" },
		{ "DisplayName", "int - int" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "Keywords", "- subtract minus" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Subtract" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_ISubstract>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_ISubstract_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_ISubstract_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_ISubstract_Statics::ClassParams = {
	&UVoxelNode_ISubstract::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_ISubstract_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_ISubstract_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_ISubstract()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_ISubstract.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_ISubstract.OuterSingleton, Z_Construct_UClass_UVoxelNode_ISubstract_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_ISubstract.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_ISubstract);
UVoxelNode_ISubstract::~UVoxelNode_ISubstract() {}
// ********** End Class UVoxelNode_ISubstract ******************************************************

// ********** Begin Class UVoxelNode_IDivide *******************************************************
void UVoxelNode_IDivide::StaticRegisterNativesUVoxelNode_IDivide()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_IDivide;
UClass* UVoxelNode_IDivide::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_IDivide;
	if (!Z_Registration_Info_UClass_UVoxelNode_IDivide.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_IDivide"),
			Z_Registration_Info_UClass_UVoxelNode_IDivide.InnerSingleton,
			StaticRegisterNativesUVoxelNode_IDivide,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_IDivide.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_IDivide_NoRegister()
{
	return UVoxelNode_IDivide::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_IDivide_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Integer" },
		{ "Comment", "// Divide\n" },
		{ "DisplayName", "int / int" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "Keywords", "/ divide division" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Divide" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_IDivide>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_IDivide_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_IDivide_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_IDivide_Statics::ClassParams = {
	&UVoxelNode_IDivide::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_IDivide_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_IDivide_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_IDivide()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_IDivide.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_IDivide.OuterSingleton, Z_Construct_UClass_UVoxelNode_IDivide_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_IDivide.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_IDivide);
UVoxelNode_IDivide::~UVoxelNode_IDivide() {}
// ********** End Class UVoxelNode_IDivide *********************************************************

// ********** Begin Class UVoxelNode_ILeftBitShift *************************************************
void UVoxelNode_ILeftBitShift::StaticRegisterNativesUVoxelNode_ILeftBitShift()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_ILeftBitShift;
UClass* UVoxelNode_ILeftBitShift::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_ILeftBitShift;
	if (!Z_Registration_Info_UClass_UVoxelNode_ILeftBitShift.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_ILeftBitShift"),
			Z_Registration_Info_UClass_UVoxelNode_ILeftBitShift.InnerSingleton,
			StaticRegisterNativesUVoxelNode_ILeftBitShift,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_ILeftBitShift.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_ILeftBitShift_NoRegister()
{
	return UVoxelNode_ILeftBitShift::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_ILeftBitShift_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Integer" },
		{ "Comment", "// Left bit shift\n" },
		{ "DisplayName", "<<" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "Keywords", "<< left bit shift" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Left bit shift" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_ILeftBitShift>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_ILeftBitShift_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_ILeftBitShift_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_ILeftBitShift_Statics::ClassParams = {
	&UVoxelNode_ILeftBitShift::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_ILeftBitShift_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_ILeftBitShift_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_ILeftBitShift()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_ILeftBitShift.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_ILeftBitShift.OuterSingleton, Z_Construct_UClass_UVoxelNode_ILeftBitShift_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_ILeftBitShift.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_ILeftBitShift);
UVoxelNode_ILeftBitShift::~UVoxelNode_ILeftBitShift() {}
// ********** End Class UVoxelNode_ILeftBitShift ***************************************************

// ********** Begin Class UVoxelNode_IRightBitShift ************************************************
void UVoxelNode_IRightBitShift::StaticRegisterNativesUVoxelNode_IRightBitShift()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_IRightBitShift;
UClass* UVoxelNode_IRightBitShift::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_IRightBitShift;
	if (!Z_Registration_Info_UClass_UVoxelNode_IRightBitShift.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_IRightBitShift"),
			Z_Registration_Info_UClass_UVoxelNode_IRightBitShift.InnerSingleton,
			StaticRegisterNativesUVoxelNode_IRightBitShift,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_IRightBitShift.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_IRightBitShift_NoRegister()
{
	return UVoxelNode_IRightBitShift::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_IRightBitShift_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Integer" },
		{ "Comment", "// Right bit shift\n" },
		{ "DisplayName", ">>" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "Keywords", ">> right bit shift" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Right bit shift" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_IRightBitShift>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_IRightBitShift_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_IRightBitShift_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_IRightBitShift_Statics::ClassParams = {
	&UVoxelNode_IRightBitShift::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_IRightBitShift_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_IRightBitShift_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_IRightBitShift()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_IRightBitShift.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_IRightBitShift.OuterSingleton, Z_Construct_UClass_UVoxelNode_IRightBitShift_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_IRightBitShift.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_IRightBitShift);
UVoxelNode_IRightBitShift::~UVoxelNode_IRightBitShift() {}
// ********** End Class UVoxelNode_IRightBitShift **************************************************

// ********** Begin Class UVoxelNode_FloatOfInt ****************************************************
void UVoxelNode_FloatOfInt::StaticRegisterNativesUVoxelNode_FloatOfInt()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_FloatOfInt;
UClass* UVoxelNode_FloatOfInt::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_FloatOfInt;
	if (!Z_Registration_Info_UClass_UVoxelNode_FloatOfInt.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_FloatOfInt"),
			Z_Registration_Info_UClass_UVoxelNode_FloatOfInt.InnerSingleton,
			StaticRegisterNativesUVoxelNode_FloatOfInt,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_FloatOfInt.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_FloatOfInt_NoRegister()
{
	return UVoxelNode_FloatOfInt::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_FloatOfInt_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Integer" },
		{ "Comment", "// Cast to float\n" },
		{ "DisplayName", "int to float" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "Keywords", "cast convert" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Cast to float" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_FloatOfInt>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_FloatOfInt_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_FloatOfInt_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_FloatOfInt_Statics::ClassParams = {
	&UVoxelNode_FloatOfInt::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_FloatOfInt_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_FloatOfInt_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_FloatOfInt()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_FloatOfInt.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_FloatOfInt.OuterSingleton, Z_Construct_UClass_UVoxelNode_FloatOfInt_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_FloatOfInt.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_FloatOfInt);
UVoxelNode_FloatOfInt::~UVoxelNode_FloatOfInt() {}
// ********** End Class UVoxelNode_FloatOfInt ******************************************************

// ********** Begin Class UVoxelNode_Round *********************************************************
void UVoxelNode_Round::StaticRegisterNativesUVoxelNode_Round()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_Round;
UClass* UVoxelNode_Round::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_Round;
	if (!Z_Registration_Info_UClass_UVoxelNode_Round.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_Round"),
			Z_Registration_Info_UClass_UVoxelNode_Round.InnerSingleton,
			StaticRegisterNativesUVoxelNode_Round,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Round.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_Round_NoRegister()
{
	return UVoxelNode_Round::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_Round_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Round to int32\n" },
		{ "DisplayName", "Round" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Round to int32" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_Round>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_Round_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Round_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_Round_Statics::ClassParams = {
	&UVoxelNode_Round::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Round_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_Round_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_Round()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_Round.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_Round.OuterSingleton, Z_Construct_UClass_UVoxelNode_Round_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Round.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_Round);
UVoxelNode_Round::~UVoxelNode_Round() {}
// ********** End Class UVoxelNode_Round ***********************************************************

// ********** Begin Class UVoxelNode_Lerp **********************************************************
void UVoxelNode_Lerp::StaticRegisterNativesUVoxelNode_Lerp()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_Lerp;
UClass* UVoxelNode_Lerp::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_Lerp;
	if (!Z_Registration_Info_UClass_UVoxelNode_Lerp.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_Lerp"),
			Z_Registration_Info_UClass_UVoxelNode_Lerp.InnerSingleton,
			StaticRegisterNativesUVoxelNode_Lerp,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Lerp.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_Lerp_NoRegister()
{
	return UVoxelNode_Lerp::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_Lerp_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Lerp between A and B. Warning: Alpha not clamped! Lerp(0, 20, 2) = 40!\n" },
		{ "DisplayName", "Lerp" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Lerp between A and B. Warning: Alpha not clamped! Lerp(0, 20, 2) = 40!" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_Lerp>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_Lerp_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Lerp_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_Lerp_Statics::ClassParams = {
	&UVoxelNode_Lerp::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Lerp_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_Lerp_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_Lerp()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_Lerp.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_Lerp.OuterSingleton, Z_Construct_UClass_UVoxelNode_Lerp_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Lerp.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_Lerp);
UVoxelNode_Lerp::~UVoxelNode_Lerp() {}
// ********** End Class UVoxelNode_Lerp ************************************************************

// ********** Begin Class UVoxelNode_SafeLerp ******************************************************
void UVoxelNode_SafeLerp::StaticRegisterNativesUVoxelNode_SafeLerp()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_SafeLerp;
UClass* UVoxelNode_SafeLerp::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_SafeLerp;
	if (!Z_Registration_Info_UClass_UVoxelNode_SafeLerp.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_SafeLerp"),
			Z_Registration_Info_UClass_UVoxelNode_SafeLerp.InnerSingleton,
			StaticRegisterNativesUVoxelNode_SafeLerp,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_SafeLerp.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_SafeLerp_NoRegister()
{
	return UVoxelNode_SafeLerp::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_SafeLerp_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Lerp between A and B, with a clamped alpha\n" },
		{ "DisplayName", "Safe Lerp" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Lerp between A and B, with a clamped alpha" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_SafeLerp>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_SafeLerp_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_SafeLerp_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_SafeLerp_Statics::ClassParams = {
	&UVoxelNode_SafeLerp::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_SafeLerp_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_SafeLerp_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_SafeLerp()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_SafeLerp.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_SafeLerp.OuterSingleton, Z_Construct_UClass_UVoxelNode_SafeLerp_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_SafeLerp.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_SafeLerp);
UVoxelNode_SafeLerp::~UVoxelNode_SafeLerp() {}
// ********** End Class UVoxelNode_SafeLerp ********************************************************

// ********** Begin Class UVoxelNode_SmoothStep ****************************************************
void UVoxelNode_SmoothStep::StaticRegisterNativesUVoxelNode_SmoothStep()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_SmoothStep;
UClass* UVoxelNode_SmoothStep::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_SmoothStep;
	if (!Z_Registration_Info_UClass_UVoxelNode_SmoothStep.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_SmoothStep"),
			Z_Registration_Info_UClass_UVoxelNode_SmoothStep.InnerSingleton,
			StaticRegisterNativesUVoxelNode_SmoothStep,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_SmoothStep.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_SmoothStep_NoRegister()
{
	return UVoxelNode_SmoothStep::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_SmoothStep_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Returns a smooth Hermite interpolation between 0 and 1 for the value X (where X ranges between A and B)\n// Clamped to 0 for X <= A and 1 for X >= B.\n" },
		{ "DisplayName", "Smooth Step" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Returns a smooth Hermite interpolation between 0 and 1 for the value X (where X ranges between A and B)\nClamped to 0 for X <= A and 1 for X >= B." },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_SmoothStep>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_SmoothStep_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_SmoothStep_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_SmoothStep_Statics::ClassParams = {
	&UVoxelNode_SmoothStep::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_SmoothStep_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_SmoothStep_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_SmoothStep()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_SmoothStep.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_SmoothStep.OuterSingleton, Z_Construct_UClass_UVoxelNode_SmoothStep_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_SmoothStep.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_SmoothStep);
UVoxelNode_SmoothStep::~UVoxelNode_SmoothStep() {}
// ********** End Class UVoxelNode_SmoothStep ******************************************************

// ********** Begin Class UVoxelNode_Clamp *********************************************************
void UVoxelNode_Clamp::StaticRegisterNativesUVoxelNode_Clamp()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_Clamp;
UClass* UVoxelNode_Clamp::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_Clamp;
	if (!Z_Registration_Info_UClass_UVoxelNode_Clamp.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_Clamp"),
			Z_Registration_Info_UClass_UVoxelNode_Clamp.InnerSingleton,
			StaticRegisterNativesUVoxelNode_Clamp,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Clamp.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_Clamp_NoRegister()
{
	return UVoxelNode_Clamp::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_Clamp_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Clamp Value between Min and Max\n" },
		{ "DisplayName", "Clamp" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Clamp Value between Min and Max" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_Clamp>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_Clamp_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Clamp_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_Clamp_Statics::ClassParams = {
	&UVoxelNode_Clamp::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Clamp_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_Clamp_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_Clamp()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_Clamp.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_Clamp.OuterSingleton, Z_Construct_UClass_UVoxelNode_Clamp_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Clamp.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_Clamp);
UVoxelNode_Clamp::~UVoxelNode_Clamp() {}
// ********** End Class UVoxelNode_Clamp ***********************************************************

// ********** Begin Class UVoxelNode_BAnd **********************************************************
void UVoxelNode_BAnd::StaticRegisterNativesUVoxelNode_BAnd()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_BAnd;
UClass* UVoxelNode_BAnd::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_BAnd;
	if (!Z_Registration_Info_UClass_UVoxelNode_BAnd.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_BAnd"),
			Z_Registration_Info_UClass_UVoxelNode_BAnd.InnerSingleton,
			StaticRegisterNativesUVoxelNode_BAnd,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_BAnd.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_BAnd_NoRegister()
{
	return UVoxelNode_BAnd::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_BAnd_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Boolean" },
		{ "Comment", "// And\n" },
		{ "DisplayName", "AND Boolean" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "Keywords", "& and" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "And" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_BAnd>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_BAnd_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_BAnd_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_BAnd_Statics::ClassParams = {
	&UVoxelNode_BAnd::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_BAnd_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_BAnd_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_BAnd()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_BAnd.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_BAnd.OuterSingleton, Z_Construct_UClass_UVoxelNode_BAnd_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_BAnd.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_BAnd);
UVoxelNode_BAnd::~UVoxelNode_BAnd() {}
// ********** End Class UVoxelNode_BAnd ************************************************************

// ********** Begin Class UVoxelNode_BOr ***********************************************************
void UVoxelNode_BOr::StaticRegisterNativesUVoxelNode_BOr()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_BOr;
UClass* UVoxelNode_BOr::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_BOr;
	if (!Z_Registration_Info_UClass_UVoxelNode_BOr.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_BOr"),
			Z_Registration_Info_UClass_UVoxelNode_BOr.InnerSingleton,
			StaticRegisterNativesUVoxelNode_BOr,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_BOr.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_BOr_NoRegister()
{
	return UVoxelNode_BOr::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_BOr_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Boolean" },
		{ "Comment", "// Or\n" },
		{ "DisplayName", "OR Boolean" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "Keywords", "| or" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Or" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_BOr>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_BOr_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_BOr_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_BOr_Statics::ClassParams = {
	&UVoxelNode_BOr::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_BOr_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_BOr_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_BOr()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_BOr.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_BOr.OuterSingleton, Z_Construct_UClass_UVoxelNode_BOr_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_BOr.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_BOr);
UVoxelNode_BOr::~UVoxelNode_BOr() {}
// ********** End Class UVoxelNode_BOr *************************************************************

// ********** Begin Class UVoxelNode_BNot **********************************************************
void UVoxelNode_BNot::StaticRegisterNativesUVoxelNode_BNot()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_BNot;
UClass* UVoxelNode_BNot::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_BNot;
	if (!Z_Registration_Info_UClass_UVoxelNode_BNot.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_BNot"),
			Z_Registration_Info_UClass_UVoxelNode_BNot.InnerSingleton,
			StaticRegisterNativesUVoxelNode_BNot,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_BNot.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_BNot_NoRegister()
{
	return UVoxelNode_BNot::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_BNot_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Boolean" },
		{ "Comment", "// Not\n" },
		{ "DisplayName", "NOT Boolean" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "Keywords", "! not" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Not" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_BNot>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_BNot_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_BNot_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_BNot_Statics::ClassParams = {
	&UVoxelNode_BNot::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_BNot_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_BNot_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_BNot()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_BNot.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_BNot.OuterSingleton, Z_Construct_UClass_UVoxelNode_BNot_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_BNot.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_BNot);
UVoxelNode_BNot::~UVoxelNode_BNot() {}
// ********** End Class UVoxelNode_BNot ************************************************************

// ********** Begin Class UVoxelNode_SwitchInt *****************************************************
void UVoxelNode_SwitchInt::StaticRegisterNativesUVoxelNode_SwitchInt()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_SwitchInt;
UClass* UVoxelNode_SwitchInt::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_SwitchInt;
	if (!Z_Registration_Info_UClass_UVoxelNode_SwitchInt.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_SwitchInt"),
			Z_Registration_Info_UClass_UVoxelNode_SwitchInt.InnerSingleton,
			StaticRegisterNativesUVoxelNode_SwitchInt,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_SwitchInt.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_SwitchInt_NoRegister()
{
	return UVoxelNode_SwitchInt::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_SwitchInt_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Integer" },
		{ "Comment", "// Switch: if bool is true, then A is returned, else B is\n" },
		{ "DisplayName", "Switch (int)" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "Keywords", "if branch select" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Switch: if bool is true, then A is returned, else B is" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_SwitchInt>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_SwitchInt_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelNodeHelper,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_SwitchInt_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_SwitchInt_Statics::ClassParams = {
	&UVoxelNode_SwitchInt::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_SwitchInt_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_SwitchInt_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_SwitchInt()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_SwitchInt.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_SwitchInt.OuterSingleton, Z_Construct_UClass_UVoxelNode_SwitchInt_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_SwitchInt.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_SwitchInt);
UVoxelNode_SwitchInt::~UVoxelNode_SwitchInt() {}
// ********** End Class UVoxelNode_SwitchInt *******************************************************

// ********** Begin Class UVoxelNode_SwitchFloat ***************************************************
void UVoxelNode_SwitchFloat::StaticRegisterNativesUVoxelNode_SwitchFloat()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_SwitchFloat;
UClass* UVoxelNode_SwitchFloat::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_SwitchFloat;
	if (!Z_Registration_Info_UClass_UVoxelNode_SwitchFloat.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_SwitchFloat"),
			Z_Registration_Info_UClass_UVoxelNode_SwitchFloat.InnerSingleton,
			StaticRegisterNativesUVoxelNode_SwitchFloat,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_SwitchFloat.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_SwitchFloat_NoRegister()
{
	return UVoxelNode_SwitchFloat::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_SwitchFloat_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Switch: if bool is true, then A is returned, else B is\n" },
		{ "DisplayName", "Switch (float)" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "Keywords", "if branch select" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Switch: if bool is true, then A is returned, else B is" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_SwitchFloat>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_SwitchFloat_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelNodeHelper,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_SwitchFloat_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_SwitchFloat_Statics::ClassParams = {
	&UVoxelNode_SwitchFloat::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_SwitchFloat_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_SwitchFloat_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_SwitchFloat()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_SwitchFloat.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_SwitchFloat.OuterSingleton, Z_Construct_UClass_UVoxelNode_SwitchFloat_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_SwitchFloat.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_SwitchFloat);
UVoxelNode_SwitchFloat::~UVoxelNode_SwitchFloat() {}
// ********** End Class UVoxelNode_SwitchFloat *****************************************************

// ********** Begin Class UVoxelNode_SwitchColor ***************************************************
void UVoxelNode_SwitchColor::StaticRegisterNativesUVoxelNode_SwitchColor()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_SwitchColor;
UClass* UVoxelNode_SwitchColor::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_SwitchColor;
	if (!Z_Registration_Info_UClass_UVoxelNode_SwitchColor.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_SwitchColor"),
			Z_Registration_Info_UClass_UVoxelNode_SwitchColor.InnerSingleton,
			StaticRegisterNativesUVoxelNode_SwitchColor,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_SwitchColor.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_SwitchColor_NoRegister()
{
	return UVoxelNode_SwitchColor::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_SwitchColor_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Color" },
		{ "Comment", "// Switch: if bool is true, then A is returned, else B is\n" },
		{ "DisplayName", "Switch (color)" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "Keywords", "if branch select" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Switch: if bool is true, then A is returned, else B is" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_SwitchColor>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_SwitchColor_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelNodeHelper,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_SwitchColor_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_SwitchColor_Statics::ClassParams = {
	&UVoxelNode_SwitchColor::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_SwitchColor_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_SwitchColor_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_SwitchColor()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_SwitchColor.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_SwitchColor.OuterSingleton, Z_Construct_UClass_UVoxelNode_SwitchColor_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_SwitchColor.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_SwitchColor);
UVoxelNode_SwitchColor::~UVoxelNode_SwitchColor() {}
// ********** End Class UVoxelNode_SwitchColor *****************************************************

// ********** Begin Class UVoxelNode_1MinusX *******************************************************
void UVoxelNode_1MinusX::StaticRegisterNativesUVoxelNode_1MinusX()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_1MinusX;
UClass* UVoxelNode_1MinusX::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_1MinusX;
	if (!Z_Registration_Info_UClass_UVoxelNode_1MinusX.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_1MinusX"),
			Z_Registration_Info_UClass_UVoxelNode_1MinusX.InnerSingleton,
			StaticRegisterNativesUVoxelNode_1MinusX,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_1MinusX.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_1MinusX_NoRegister()
{
	return UVoxelNode_1MinusX::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_1MinusX_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// 1 - X\n" },
		{ "DisplayName", "1 - X" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "1 - X" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_1MinusX>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_1MinusX_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_1MinusX_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_1MinusX_Statics::ClassParams = {
	&UVoxelNode_1MinusX::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_1MinusX_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_1MinusX_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_1MinusX()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_1MinusX.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_1MinusX.OuterSingleton, Z_Construct_UClass_UVoxelNode_1MinusX_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_1MinusX.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_1MinusX);
UVoxelNode_1MinusX::~UVoxelNode_1MinusX() {}
// ********** End Class UVoxelNode_1MinusX *********************************************************

// ********** Begin Class UVoxelNode_OneOverX ******************************************************
void UVoxelNode_OneOverX::StaticRegisterNativesUVoxelNode_OneOverX()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_OneOverX;
UClass* UVoxelNode_OneOverX::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_OneOverX;
	if (!Z_Registration_Info_UClass_UVoxelNode_OneOverX.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_OneOverX"),
			Z_Registration_Info_UClass_UVoxelNode_OneOverX.InnerSingleton,
			StaticRegisterNativesUVoxelNode_OneOverX,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_OneOverX.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_OneOverX_NoRegister()
{
	return UVoxelNode_OneOverX::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_OneOverX_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// 1 / X\n" },
		{ "DisplayName", "1 / X" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "1 / X" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_OneOverX>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_OneOverX_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_OneOverX_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_OneOverX_Statics::ClassParams = {
	&UVoxelNode_OneOverX::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_OneOverX_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_OneOverX_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_OneOverX()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_OneOverX.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_OneOverX.OuterSingleton, Z_Construct_UClass_UVoxelNode_OneOverX_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_OneOverX.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_OneOverX);
UVoxelNode_OneOverX::~UVoxelNode_OneOverX() {}
// ********** End Class UVoxelNode_OneOverX ********************************************************

// ********** Begin Class UVoxelNode_MinusX ********************************************************
void UVoxelNode_MinusX::StaticRegisterNativesUVoxelNode_MinusX()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_MinusX;
UClass* UVoxelNode_MinusX::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_MinusX;
	if (!Z_Registration_Info_UClass_UVoxelNode_MinusX.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_MinusX"),
			Z_Registration_Info_UClass_UVoxelNode_MinusX.InnerSingleton,
			StaticRegisterNativesUVoxelNode_MinusX,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_MinusX.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_MinusX_NoRegister()
{
	return UVoxelNode_MinusX::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_MinusX_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// -X\n" },
		{ "DisplayName", "* -1" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "-X" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_MinusX>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_MinusX_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_MinusX_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_MinusX_Statics::ClassParams = {
	&UVoxelNode_MinusX::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_MinusX_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_MinusX_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_MinusX()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_MinusX.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_MinusX.OuterSingleton, Z_Construct_UClass_UVoxelNode_MinusX_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_MinusX.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_MinusX);
UVoxelNode_MinusX::~UVoxelNode_MinusX() {}
// ********** End Class UVoxelNode_MinusX **********************************************************

// ********** Begin Class UVoxelNode_Sqrt **********************************************************
void UVoxelNode_Sqrt::StaticRegisterNativesUVoxelNode_Sqrt()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_Sqrt;
UClass* UVoxelNode_Sqrt::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_Sqrt;
	if (!Z_Registration_Info_UClass_UVoxelNode_Sqrt.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_Sqrt"),
			Z_Registration_Info_UClass_UVoxelNode_Sqrt.InnerSingleton,
			StaticRegisterNativesUVoxelNode_Sqrt,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Sqrt.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_Sqrt_NoRegister()
{
	return UVoxelNode_Sqrt::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_Sqrt_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Square root\n" },
		{ "DisplayName", "Sqrt" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Square root" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_Sqrt>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_Sqrt_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Sqrt_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_Sqrt_Statics::ClassParams = {
	&UVoxelNode_Sqrt::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Sqrt_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_Sqrt_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_Sqrt()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_Sqrt.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_Sqrt.OuterSingleton, Z_Construct_UClass_UVoxelNode_Sqrt_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Sqrt.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_Sqrt);
UVoxelNode_Sqrt::~UVoxelNode_Sqrt() {}
// ********** End Class UVoxelNode_Sqrt ************************************************************

// ********** Begin Class UVoxelNode_Pow ***********************************************************
void UVoxelNode_Pow::StaticRegisterNativesUVoxelNode_Pow()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_Pow;
UClass* UVoxelNode_Pow::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_Pow;
	if (!Z_Registration_Info_UClass_UVoxelNode_Pow.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_Pow"),
			Z_Registration_Info_UClass_UVoxelNode_Pow.InnerSingleton,
			StaticRegisterNativesUVoxelNode_Pow,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Pow.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_Pow_NoRegister()
{
	return UVoxelNode_Pow::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_Pow_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Pow\n" },
		{ "DisplayName", "Pow" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Pow" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_Pow>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_Pow_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Pow_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_Pow_Statics::ClassParams = {
	&UVoxelNode_Pow::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Pow_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_Pow_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_Pow()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_Pow.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_Pow.OuterSingleton, Z_Construct_UClass_UVoxelNode_Pow_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Pow.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_Pow);
UVoxelNode_Pow::~UVoxelNode_Pow() {}
// ********** End Class UVoxelNode_Pow *************************************************************

// ********** Begin Class UVoxelNode_IMod **********************************************************
void UVoxelNode_IMod::StaticRegisterNativesUVoxelNode_IMod()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_IMod;
UClass* UVoxelNode_IMod::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_IMod;
	if (!Z_Registration_Info_UClass_UVoxelNode_IMod.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_IMod"),
			Z_Registration_Info_UClass_UVoxelNode_IMod.InnerSingleton,
			StaticRegisterNativesUVoxelNode_IMod,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_IMod.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_IMod_NoRegister()
{
	return UVoxelNode_IMod::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_IMod_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Integer" },
		{ "Comment", "// Modulo\n" },
		{ "DisplayName", "% (int)" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "Keywords", "% modulus" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Modulo" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_IMod>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_IMod_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_IMod_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_IMod_Statics::ClassParams = {
	&UVoxelNode_IMod::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_IMod_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_IMod_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_IMod()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_IMod.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_IMod.OuterSingleton, Z_Construct_UClass_UVoxelNode_IMod_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_IMod.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_IMod);
UVoxelNode_IMod::~UVoxelNode_IMod() {}
// ********** End Class UVoxelNode_IMod ************************************************************

// ********** Begin Class UVoxelNode_FMod **********************************************************
void UVoxelNode_FMod::StaticRegisterNativesUVoxelNode_FMod()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_FMod;
UClass* UVoxelNode_FMod::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_FMod;
	if (!Z_Registration_Info_UClass_UVoxelNode_FMod.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_FMod"),
			Z_Registration_Info_UClass_UVoxelNode_FMod.InnerSingleton,
			StaticRegisterNativesUVoxelNode_FMod,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_FMod.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_FMod_NoRegister()
{
	return UVoxelNode_FMod::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_FMod_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "/**\n * Returns the floating-point remainder of X / Y\n * Warning: Always returns remainder toward 0, not toward the smaller multiple of Y.\n *\x09\x09\x09So for example Fmod(2.8f, 2) gives .8f as you would expect, however, Fmod(-2.8f, 2) gives -.8f, NOT 1.2f\n * Use Floor instead when snapping positions that can be negative to a grid\n */" },
		{ "DisplayName", "FMod" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "Keywords", "% modulus fmod" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Returns the floating-point remainder of X / Y\nWarning: Always returns remainder toward 0, not toward the smaller multiple of Y.\n                    So for example Fmod(2.8f, 2) gives .8f as you would expect, however, Fmod(-2.8f, 2) gives -.8f, NOT 1.2f\nUse Floor instead when snapping positions that can be negative to a grid" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_FMod>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_FMod_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_FMod_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_FMod_Statics::ClassParams = {
	&UVoxelNode_FMod::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_FMod_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_FMod_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_FMod()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_FMod.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_FMod.OuterSingleton, Z_Construct_UClass_UVoxelNode_FMod_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_FMod.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_FMod);
UVoxelNode_FMod::~UVoxelNode_FMod() {}
// ********** End Class UVoxelNode_FMod ************************************************************

// ********** Begin Class UVoxelNode_FAbs **********************************************************
void UVoxelNode_FAbs::StaticRegisterNativesUVoxelNode_FAbs()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_FAbs;
UClass* UVoxelNode_FAbs::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_FAbs;
	if (!Z_Registration_Info_UClass_UVoxelNode_FAbs.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_FAbs"),
			Z_Registration_Info_UClass_UVoxelNode_FAbs.InnerSingleton,
			StaticRegisterNativesUVoxelNode_FAbs,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_FAbs.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_FAbs_NoRegister()
{
	return UVoxelNode_FAbs::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_FAbs_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Absolute value\n" },
		{ "DisplayName", "Absolute (float)" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Absolute value" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_FAbs>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_FAbs_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_FAbs_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_FAbs_Statics::ClassParams = {
	&UVoxelNode_FAbs::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_FAbs_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_FAbs_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_FAbs()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_FAbs.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_FAbs.OuterSingleton, Z_Construct_UClass_UVoxelNode_FAbs_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_FAbs.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_FAbs);
UVoxelNode_FAbs::~UVoxelNode_FAbs() {}
// ********** End Class UVoxelNode_FAbs ************************************************************

// ********** Begin Class UVoxelNode_IAbs **********************************************************
void UVoxelNode_IAbs::StaticRegisterNativesUVoxelNode_IAbs()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_IAbs;
UClass* UVoxelNode_IAbs::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_IAbs;
	if (!Z_Registration_Info_UClass_UVoxelNode_IAbs.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_IAbs"),
			Z_Registration_Info_UClass_UVoxelNode_IAbs.InnerSingleton,
			StaticRegisterNativesUVoxelNode_IAbs,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_IAbs.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_IAbs_NoRegister()
{
	return UVoxelNode_IAbs::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_IAbs_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Integer" },
		{ "Comment", "// Absolute value\n" },
		{ "DisplayName", "Absolute (int)" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Absolute value" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_IAbs>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_IAbs_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_IAbs_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_IAbs_Statics::ClassParams = {
	&UVoxelNode_IAbs::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_IAbs_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_IAbs_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_IAbs()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_IAbs.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_IAbs.OuterSingleton, Z_Construct_UClass_UVoxelNode_IAbs_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_IAbs.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_IAbs);
UVoxelNode_IAbs::~UVoxelNode_IAbs() {}
// ********** End Class UVoxelNode_IAbs ************************************************************

// ********** Begin Class UVoxelNode_Ceil **********************************************************
void UVoxelNode_Ceil::StaticRegisterNativesUVoxelNode_Ceil()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_Ceil;
UClass* UVoxelNode_Ceil::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_Ceil;
	if (!Z_Registration_Info_UClass_UVoxelNode_Ceil.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_Ceil"),
			Z_Registration_Info_UClass_UVoxelNode_Ceil.InnerSingleton,
			StaticRegisterNativesUVoxelNode_Ceil,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Ceil.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_Ceil_NoRegister()
{
	return UVoxelNode_Ceil::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_Ceil_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Returns the smallest integer greater than or equal to the input\n" },
		{ "DisplayName", "Ceil" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Returns the smallest integer greater than or equal to the input" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_Ceil>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_Ceil_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Ceil_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_Ceil_Statics::ClassParams = {
	&UVoxelNode_Ceil::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Ceil_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_Ceil_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_Ceil()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_Ceil.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_Ceil.OuterSingleton, Z_Construct_UClass_UVoxelNode_Ceil_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Ceil.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_Ceil);
UVoxelNode_Ceil::~UVoxelNode_Ceil() {}
// ********** End Class UVoxelNode_Ceil ************************************************************

// ********** Begin Class UVoxelNode_Floor *********************************************************
void UVoxelNode_Floor::StaticRegisterNativesUVoxelNode_Floor()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_Floor;
UClass* UVoxelNode_Floor::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_Floor;
	if (!Z_Registration_Info_UClass_UVoxelNode_Floor.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_Floor"),
			Z_Registration_Info_UClass_UVoxelNode_Floor.InnerSingleton,
			StaticRegisterNativesUVoxelNode_Floor,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Floor.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_Floor_NoRegister()
{
	return UVoxelNode_Floor::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_Floor_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Returns the largest integer less than or equal to the input\n" },
		{ "DisplayName", "Floor" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Returns the largest integer less than or equal to the input" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_Floor>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_Floor_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Floor_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_Floor_Statics::ClassParams = {
	&UVoxelNode_Floor::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Floor_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_Floor_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_Floor()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_Floor.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_Floor.OuterSingleton, Z_Construct_UClass_UVoxelNode_Floor_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Floor.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_Floor);
UVoxelNode_Floor::~UVoxelNode_Floor() {}
// ********** End Class UVoxelNode_Floor ***********************************************************

// ********** Begin Class UVoxelNode_VectorLength **************************************************
void UVoxelNode_VectorLength::StaticRegisterNativesUVoxelNode_VectorLength()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_VectorLength;
UClass* UVoxelNode_VectorLength::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_VectorLength;
	if (!Z_Registration_Info_UClass_UVoxelNode_VectorLength.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_VectorLength"),
			Z_Registration_Info_UClass_UVoxelNode_VectorLength.InnerSingleton,
			StaticRegisterNativesUVoxelNode_VectorLength,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_VectorLength.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_VectorLength_NoRegister()
{
	return UVoxelNode_VectorLength::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_VectorLength_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Vector" },
		{ "Comment", "// Return the length of (X, Y, Z)\n" },
		{ "DisplayName", "Vector Length" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Return the length of (X, Y, Z)" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_VectorLength>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_VectorLength_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_VectorLength_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_VectorLength_Statics::ClassParams = {
	&UVoxelNode_VectorLength::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_VectorLength_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_VectorLength_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_VectorLength()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_VectorLength.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_VectorLength.OuterSingleton, Z_Construct_UClass_UVoxelNode_VectorLength_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_VectorLength.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_VectorLength);
UVoxelNode_VectorLength::~UVoxelNode_VectorLength() {}
// ********** End Class UVoxelNode_VectorLength ****************************************************

// ********** Begin Class UVoxelNode_Fraction ******************************************************
void UVoxelNode_Fraction::StaticRegisterNativesUVoxelNode_Fraction()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_Fraction;
UClass* UVoxelNode_Fraction::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_Fraction;
	if (!Z_Registration_Info_UClass_UVoxelNode_Fraction.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_Fraction"),
			Z_Registration_Info_UClass_UVoxelNode_Fraction.InnerSingleton,
			StaticRegisterNativesUVoxelNode_Fraction,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Fraction.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_Fraction_NoRegister()
{
	return UVoxelNode_Fraction::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_Fraction_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Return the signed fractional part of the input (ie 9.45 -> 0.45). Negative if the input is negative\n" },
		{ "DisplayName", "Fraction" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Return the signed fractional part of the input (ie 9.45 -> 0.45). Negative if the input is negative" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_Fraction>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_Fraction_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Fraction_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_Fraction_Statics::ClassParams = {
	&UVoxelNode_Fraction::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Fraction_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_Fraction_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_Fraction()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_Fraction.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_Fraction.OuterSingleton, Z_Construct_UClass_UVoxelNode_Fraction_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Fraction.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_Fraction);
UVoxelNode_Fraction::~UVoxelNode_Fraction() {}
// ********** End Class UVoxelNode_Fraction ********************************************************

// ********** Begin Class UVoxelNode_FSign *********************************************************
void UVoxelNode_FSign::StaticRegisterNativesUVoxelNode_FSign()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_FSign;
UClass* UVoxelNode_FSign::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_FSign;
	if (!Z_Registration_Info_UClass_UVoxelNode_FSign.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_FSign"),
			Z_Registration_Info_UClass_UVoxelNode_FSign.InnerSingleton,
			StaticRegisterNativesUVoxelNode_FSign,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_FSign.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_FSign_NoRegister()
{
	return UVoxelNode_FSign::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_FSign_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Return the sign of the input (1, 0 or -1)\n" },
		{ "DisplayName", "Sign (float)" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Return the sign of the input (1, 0 or -1)" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_FSign>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_FSign_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_FSign_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_FSign_Statics::ClassParams = {
	&UVoxelNode_FSign::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_FSign_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_FSign_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_FSign()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_FSign.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_FSign.OuterSingleton, Z_Construct_UClass_UVoxelNode_FSign_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_FSign.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_FSign);
UVoxelNode_FSign::~UVoxelNode_FSign() {}
// ********** End Class UVoxelNode_FSign ***********************************************************

// ********** Begin Class UVoxelNode_ISign *********************************************************
void UVoxelNode_ISign::StaticRegisterNativesUVoxelNode_ISign()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_ISign;
UClass* UVoxelNode_ISign::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_ISign;
	if (!Z_Registration_Info_UClass_UVoxelNode_ISign.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_ISign"),
			Z_Registration_Info_UClass_UVoxelNode_ISign.InnerSingleton,
			StaticRegisterNativesUVoxelNode_ISign,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_ISign.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_ISign_NoRegister()
{
	return UVoxelNode_ISign::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_ISign_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Integer" },
		{ "Comment", "// Return the sign of the input (1, 0 or -1)\n" },
		{ "DisplayName", "Sign (int)" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Return the sign of the input (1, 0 or -1)" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_ISign>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_ISign_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_ISign_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_ISign_Statics::ClassParams = {
	&UVoxelNode_ISign::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_ISign_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_ISign_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_ISign()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_ISign.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_ISign.OuterSingleton, Z_Construct_UClass_UVoxelNode_ISign_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_ISign.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_ISign);
UVoxelNode_ISign::~UVoxelNode_ISign() {}
// ********** End Class UVoxelNode_ISign ***********************************************************

// ********** Begin Class UVoxelNode_InvSqrt *******************************************************
void UVoxelNode_InvSqrt::StaticRegisterNativesUVoxelNode_InvSqrt()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_InvSqrt;
UClass* UVoxelNode_InvSqrt::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_InvSqrt;
	if (!Z_Registration_Info_UClass_UVoxelNode_InvSqrt.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_InvSqrt"),
			Z_Registration_Info_UClass_UVoxelNode_InvSqrt.InnerSingleton,
			StaticRegisterNativesUVoxelNode_InvSqrt,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_InvSqrt.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_InvSqrt_NoRegister()
{
	return UVoxelNode_InvSqrt::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_InvSqrt_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Return the inverse square root of the input\n" },
		{ "DisplayName", "InvSqrt" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Return the inverse square root of the input" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_InvSqrt>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_InvSqrt_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_InvSqrt_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_InvSqrt_Statics::ClassParams = {
	&UVoxelNode_InvSqrt::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_InvSqrt_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_InvSqrt_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_InvSqrt()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_InvSqrt.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_InvSqrt.OuterSingleton, Z_Construct_UClass_UVoxelNode_InvSqrt_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_InvSqrt.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_InvSqrt);
UVoxelNode_InvSqrt::~UVoxelNode_InvSqrt() {}
// ********** End Class UVoxelNode_InvSqrt *********************************************************

// ********** Begin Class UVoxelNode_Loge **********************************************************
void UVoxelNode_Loge::StaticRegisterNativesUVoxelNode_Loge()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_Loge;
UClass* UVoxelNode_Loge::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_Loge;
	if (!Z_Registration_Info_UClass_UVoxelNode_Loge.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_Loge"),
			Z_Registration_Info_UClass_UVoxelNode_Loge.InnerSingleton,
			StaticRegisterNativesUVoxelNode_Loge,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Loge.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_Loge_NoRegister()
{
	return UVoxelNode_Loge::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_Loge_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Return the loge of the input\n" },
		{ "DisplayName", "Loge" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Return the loge of the input" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_Loge>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_Loge_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Loge_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_Loge_Statics::ClassParams = {
	&UVoxelNode_Loge::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Loge_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_Loge_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_Loge()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_Loge.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_Loge.OuterSingleton, Z_Construct_UClass_UVoxelNode_Loge_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Loge.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_Loge);
UVoxelNode_Loge::~UVoxelNode_Loge() {}
// ********** End Class UVoxelNode_Loge ************************************************************

// ********** Begin Class UVoxelNode_Exp ***********************************************************
void UVoxelNode_Exp::StaticRegisterNativesUVoxelNode_Exp()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_Exp;
UClass* UVoxelNode_Exp::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_Exp;
	if (!Z_Registration_Info_UClass_UVoxelNode_Exp.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_Exp"),
			Z_Registration_Info_UClass_UVoxelNode_Exp.InnerSingleton,
			StaticRegisterNativesUVoxelNode_Exp,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Exp.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_Exp_NoRegister()
{
	return UVoxelNode_Exp::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_Exp_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Return the exponential of the input\n" },
		{ "DisplayName", "Exp" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Return the exponential of the input" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_Exp>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_Exp_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Exp_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_Exp_Statics::ClassParams = {
	&UVoxelNode_Exp::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Exp_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_Exp_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_Exp()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_Exp.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_Exp.OuterSingleton, Z_Construct_UClass_UVoxelNode_Exp_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Exp.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_Exp);
UVoxelNode_Exp::~UVoxelNode_Exp() {}
// ********** End Class UVoxelNode_Exp *************************************************************

// ********** Begin Class UVoxelNode_Sin ***********************************************************
void UVoxelNode_Sin::StaticRegisterNativesUVoxelNode_Sin()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_Sin;
UClass* UVoxelNode_Sin::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_Sin;
	if (!Z_Registration_Info_UClass_UVoxelNode_Sin.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_Sin"),
			Z_Registration_Info_UClass_UVoxelNode_Sin.InnerSingleton,
			StaticRegisterNativesUVoxelNode_Sin,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Sin.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_Sin_NoRegister()
{
	return UVoxelNode_Sin::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_Sin_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Return the sine of the input\n// Input is in radians\n" },
		{ "DisplayName", "Sin" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Return the sine of the input\nInput is in radians" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_Sin>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_Sin_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Sin_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_Sin_Statics::ClassParams = {
	&UVoxelNode_Sin::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Sin_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_Sin_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_Sin()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_Sin.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_Sin.OuterSingleton, Z_Construct_UClass_UVoxelNode_Sin_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Sin.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_Sin);
UVoxelNode_Sin::~UVoxelNode_Sin() {}
// ********** End Class UVoxelNode_Sin *************************************************************

// ********** Begin Class UVoxelNode_Asin **********************************************************
void UVoxelNode_Asin::StaticRegisterNativesUVoxelNode_Asin()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_Asin;
UClass* UVoxelNode_Asin::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_Asin;
	if (!Z_Registration_Info_UClass_UVoxelNode_Asin.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_Asin"),
			Z_Registration_Info_UClass_UVoxelNode_Asin.InnerSingleton,
			StaticRegisterNativesUVoxelNode_Asin,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Asin.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_Asin_NoRegister()
{
	return UVoxelNode_Asin::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_Asin_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Return the asin (inverse of sine) of the input\n// Output is in radians\n" },
		{ "DisplayName", "Asin" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Return the asin (inverse of sine) of the input\nOutput is in radians" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_Asin>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_Asin_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Asin_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_Asin_Statics::ClassParams = {
	&UVoxelNode_Asin::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Asin_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_Asin_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_Asin()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_Asin.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_Asin.OuterSingleton, Z_Construct_UClass_UVoxelNode_Asin_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Asin.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_Asin);
UVoxelNode_Asin::~UVoxelNode_Asin() {}
// ********** End Class UVoxelNode_Asin ************************************************************

// ********** Begin Class UVoxelNode_Sinh **********************************************************
void UVoxelNode_Sinh::StaticRegisterNativesUVoxelNode_Sinh()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_Sinh;
UClass* UVoxelNode_Sinh::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_Sinh;
	if (!Z_Registration_Info_UClass_UVoxelNode_Sinh.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_Sinh"),
			Z_Registration_Info_UClass_UVoxelNode_Sinh.InnerSingleton,
			StaticRegisterNativesUVoxelNode_Sinh,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Sinh.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_Sinh_NoRegister()
{
	return UVoxelNode_Sinh::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_Sinh_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Return the sinh (hyperbolic sine) of the input\n// Input is in radians\n" },
		{ "DisplayName", "Sinh" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Return the sinh (hyperbolic sine) of the input\nInput is in radians" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_Sinh>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_Sinh_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Sinh_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_Sinh_Statics::ClassParams = {
	&UVoxelNode_Sinh::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Sinh_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_Sinh_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_Sinh()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_Sinh.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_Sinh.OuterSingleton, Z_Construct_UClass_UVoxelNode_Sinh_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Sinh.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_Sinh);
UVoxelNode_Sinh::~UVoxelNode_Sinh() {}
// ********** End Class UVoxelNode_Sinh ************************************************************

// ********** Begin Class UVoxelNode_Cos ***********************************************************
void UVoxelNode_Cos::StaticRegisterNativesUVoxelNode_Cos()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_Cos;
UClass* UVoxelNode_Cos::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_Cos;
	if (!Z_Registration_Info_UClass_UVoxelNode_Cos.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_Cos"),
			Z_Registration_Info_UClass_UVoxelNode_Cos.InnerSingleton,
			StaticRegisterNativesUVoxelNode_Cos,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Cos.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_Cos_NoRegister()
{
	return UVoxelNode_Cos::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_Cos_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Return the cosine of the input\n// Input is in radians\n" },
		{ "DisplayName", "Cos" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Return the cosine of the input\nInput is in radians" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_Cos>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_Cos_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Cos_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_Cos_Statics::ClassParams = {
	&UVoxelNode_Cos::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Cos_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_Cos_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_Cos()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_Cos.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_Cos.OuterSingleton, Z_Construct_UClass_UVoxelNode_Cos_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Cos.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_Cos);
UVoxelNode_Cos::~UVoxelNode_Cos() {}
// ********** End Class UVoxelNode_Cos *************************************************************

// ********** Begin Class UVoxelNode_Acos **********************************************************
void UVoxelNode_Acos::StaticRegisterNativesUVoxelNode_Acos()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_Acos;
UClass* UVoxelNode_Acos::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_Acos;
	if (!Z_Registration_Info_UClass_UVoxelNode_Acos.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_Acos"),
			Z_Registration_Info_UClass_UVoxelNode_Acos.InnerSingleton,
			StaticRegisterNativesUVoxelNode_Acos,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Acos.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_Acos_NoRegister()
{
	return UVoxelNode_Acos::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_Acos_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Return the acos (inverse of cosine) of the input\n// Output is in radians\n" },
		{ "DisplayName", "Acos" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Return the acos (inverse of cosine) of the input\nOutput is in radians" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_Acos>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_Acos_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Acos_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_Acos_Statics::ClassParams = {
	&UVoxelNode_Acos::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Acos_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_Acos_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_Acos()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_Acos.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_Acos.OuterSingleton, Z_Construct_UClass_UVoxelNode_Acos_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Acos.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_Acos);
UVoxelNode_Acos::~UVoxelNode_Acos() {}
// ********** End Class UVoxelNode_Acos ************************************************************

// ********** Begin Class UVoxelNode_SinCos ********************************************************
void UVoxelNode_SinCos::StaticRegisterNativesUVoxelNode_SinCos()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_SinCos;
UClass* UVoxelNode_SinCos::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_SinCos;
	if (!Z_Registration_Info_UClass_UVoxelNode_SinCos.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_SinCos"),
			Z_Registration_Info_UClass_UVoxelNode_SinCos.InnerSingleton,
			StaticRegisterNativesUVoxelNode_SinCos,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_SinCos.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_SinCos_NoRegister()
{
	return UVoxelNode_SinCos::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_SinCos_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Return the Sinus and Cosinus of the input\n// Input is in radians\n" },
		{ "DisplayName", "SinCos" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Return the Sinus and Cosinus of the input\nInput is in radians" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_SinCos>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_SinCos_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_SinCos_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_SinCos_Statics::ClassParams = {
	&UVoxelNode_SinCos::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_SinCos_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_SinCos_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_SinCos()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_SinCos.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_SinCos.OuterSingleton, Z_Construct_UClass_UVoxelNode_SinCos_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_SinCos.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_SinCos);
UVoxelNode_SinCos::~UVoxelNode_SinCos() {}
// ********** End Class UVoxelNode_SinCos **********************************************************

// ********** Begin Class UVoxelNode_Tan ***********************************************************
void UVoxelNode_Tan::StaticRegisterNativesUVoxelNode_Tan()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_Tan;
UClass* UVoxelNode_Tan::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_Tan;
	if (!Z_Registration_Info_UClass_UVoxelNode_Tan.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_Tan"),
			Z_Registration_Info_UClass_UVoxelNode_Tan.InnerSingleton,
			StaticRegisterNativesUVoxelNode_Tan,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Tan.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_Tan_NoRegister()
{
	return UVoxelNode_Tan::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_Tan_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Return the tan of the input\n// Input is in radians\n" },
		{ "DisplayName", "Tan" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Return the tan of the input\nInput is in radians" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_Tan>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_Tan_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Tan_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_Tan_Statics::ClassParams = {
	&UVoxelNode_Tan::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Tan_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_Tan_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_Tan()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_Tan.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_Tan.OuterSingleton, Z_Construct_UClass_UVoxelNode_Tan_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Tan.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_Tan);
UVoxelNode_Tan::~UVoxelNode_Tan() {}
// ********** End Class UVoxelNode_Tan *************************************************************

// ********** Begin Class UVoxelNode_Atan **********************************************************
void UVoxelNode_Atan::StaticRegisterNativesUVoxelNode_Atan()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_Atan;
UClass* UVoxelNode_Atan::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_Atan;
	if (!Z_Registration_Info_UClass_UVoxelNode_Atan.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_Atan"),
			Z_Registration_Info_UClass_UVoxelNode_Atan.InnerSingleton,
			StaticRegisterNativesUVoxelNode_Atan,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Atan.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_Atan_NoRegister()
{
	return UVoxelNode_Atan::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_Atan_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Return the atan of the input\n// Output is in radians\n" },
		{ "DisplayName", "Atan" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Return the atan of the input\nOutput is in radians" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_Atan>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_Atan_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Atan_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_Atan_Statics::ClassParams = {
	&UVoxelNode_Atan::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Atan_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_Atan_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_Atan()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_Atan.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_Atan.OuterSingleton, Z_Construct_UClass_UVoxelNode_Atan_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Atan.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_Atan);
UVoxelNode_Atan::~UVoxelNode_Atan() {}
// ********** End Class UVoxelNode_Atan ************************************************************

// ********** Begin Class UVoxelNode_Atan2 *********************************************************
void UVoxelNode_Atan2::StaticRegisterNativesUVoxelNode_Atan2()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_Atan2;
UClass* UVoxelNode_Atan2::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_Atan2;
	if (!Z_Registration_Info_UClass_UVoxelNode_Atan2.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_Atan2"),
			Z_Registration_Info_UClass_UVoxelNode_Atan2.InnerSingleton,
			StaticRegisterNativesUVoxelNode_Atan2,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Atan2.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_Atan2_NoRegister()
{
	return UVoxelNode_Atan2::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_Atan2_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Return atan2(Y, X)\n// Input is in radians\n" },
		{ "DisplayName", "Atan2" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Return atan2(Y, X)\nInput is in radians" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_Atan2>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_Atan2_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Atan2_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_Atan2_Statics::ClassParams = {
	&UVoxelNode_Atan2::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Atan2_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_Atan2_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_Atan2()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_Atan2.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_Atan2.OuterSingleton, Z_Construct_UClass_UVoxelNode_Atan2_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Atan2.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_Atan2);
UVoxelNode_Atan2::~UVoxelNode_Atan2() {}
// ********** End Class UVoxelNode_Atan2 ***********************************************************

// ********** Begin Class UVoxelNode_VectorRotateAngleAxis *****************************************
void UVoxelNode_VectorRotateAngleAxis::StaticRegisterNativesUVoxelNode_VectorRotateAngleAxis()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_VectorRotateAngleAxis;
UClass* UVoxelNode_VectorRotateAngleAxis::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_VectorRotateAngleAxis;
	if (!Z_Registration_Info_UClass_UVoxelNode_VectorRotateAngleAxis.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_VectorRotateAngleAxis"),
			Z_Registration_Info_UClass_UVoxelNode_VectorRotateAngleAxis.InnerSingleton,
			StaticRegisterNativesUVoxelNode_VectorRotateAngleAxis,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_VectorRotateAngleAxis.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_VectorRotateAngleAxis_NoRegister()
{
	return UVoxelNode_VectorRotateAngleAxis::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_VectorRotateAngleAxis_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Vector" },
		{ "Comment", "// Rotates around Axis (assumes Axis.Size() == 1). Angle is in degrees\n" },
		{ "DisplayName", "Vector Rotate Angle Axis" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Rotates around Axis (assumes Axis.Size() == 1). Angle is in degrees" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_VectorRotateAngleAxis>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_VectorRotateAngleAxis_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_VectorRotateAngleAxis_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_VectorRotateAngleAxis_Statics::ClassParams = {
	&UVoxelNode_VectorRotateAngleAxis::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_VectorRotateAngleAxis_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_VectorRotateAngleAxis_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_VectorRotateAngleAxis()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_VectorRotateAngleAxis.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_VectorRotateAngleAxis.OuterSingleton, Z_Construct_UClass_UVoxelNode_VectorRotateAngleAxis_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_VectorRotateAngleAxis.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_VectorRotateAngleAxis);
UVoxelNode_VectorRotateAngleAxis::~UVoxelNode_VectorRotateAngleAxis() {}
// ********** End Class UVoxelNode_VectorRotateAngleAxis *******************************************

// ********** Begin Class UVoxelNode_BreakColorInt *************************************************
void UVoxelNode_BreakColorInt::StaticRegisterNativesUVoxelNode_BreakColorInt()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_BreakColorInt;
UClass* UVoxelNode_BreakColorInt::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_BreakColorInt;
	if (!Z_Registration_Info_UClass_UVoxelNode_BreakColorInt.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_BreakColorInt"),
			Z_Registration_Info_UClass_UVoxelNode_BreakColorInt.InnerSingleton,
			StaticRegisterNativesUVoxelNode_BreakColorInt,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_BreakColorInt.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_BreakColorInt_NoRegister()
{
	return UVoxelNode_BreakColorInt::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_BreakColorInt_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Color" },
		{ "Comment", "// Break a color into its 4 integer RGBA components\n" },
		{ "DisplayName", "Break Color Int" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Break a color into its 4 integer RGBA components" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_BreakColorInt>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_BreakColorInt_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_BreakColorInt_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_BreakColorInt_Statics::ClassParams = {
	&UVoxelNode_BreakColorInt::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_BreakColorInt_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_BreakColorInt_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_BreakColorInt()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_BreakColorInt.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_BreakColorInt.OuterSingleton, Z_Construct_UClass_UVoxelNode_BreakColorInt_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_BreakColorInt.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_BreakColorInt);
UVoxelNode_BreakColorInt::~UVoxelNode_BreakColorInt() {}
// ********** End Class UVoxelNode_BreakColorInt ***************************************************

// ********** Begin Class UVoxelNode_BreakColorFloat ***********************************************
void UVoxelNode_BreakColorFloat::StaticRegisterNativesUVoxelNode_BreakColorFloat()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_BreakColorFloat;
UClass* UVoxelNode_BreakColorFloat::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_BreakColorFloat;
	if (!Z_Registration_Info_UClass_UVoxelNode_BreakColorFloat.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_BreakColorFloat"),
			Z_Registration_Info_UClass_UVoxelNode_BreakColorFloat.InnerSingleton,
			StaticRegisterNativesUVoxelNode_BreakColorFloat,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_BreakColorFloat.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_BreakColorFloat_NoRegister()
{
	return UVoxelNode_BreakColorFloat::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_BreakColorFloat_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Color" },
		{ "Comment", "// Break a color into its 4 RGBA components, and convert them to floats between 0 and 1\n" },
		{ "DisplayName", "Break Color" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Break a color into its 4 RGBA components, and convert them to floats between 0 and 1" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_BreakColorFloat>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_BreakColorFloat_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_BreakColorFloat_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_BreakColorFloat_Statics::ClassParams = {
	&UVoxelNode_BreakColorFloat::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_BreakColorFloat_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_BreakColorFloat_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_BreakColorFloat()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_BreakColorFloat.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_BreakColorFloat.OuterSingleton, Z_Construct_UClass_UVoxelNode_BreakColorFloat_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_BreakColorFloat.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_BreakColorFloat);
UVoxelNode_BreakColorFloat::~UVoxelNode_BreakColorFloat() {}
// ********** End Class UVoxelNode_BreakColorFloat *************************************************

// ********** Begin Class UVoxelNode_MakeColorInt **************************************************
void UVoxelNode_MakeColorInt::StaticRegisterNativesUVoxelNode_MakeColorInt()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_MakeColorInt;
UClass* UVoxelNode_MakeColorInt::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_MakeColorInt;
	if (!Z_Registration_Info_UClass_UVoxelNode_MakeColorInt.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_MakeColorInt"),
			Z_Registration_Info_UClass_UVoxelNode_MakeColorInt.InnerSingleton,
			StaticRegisterNativesUVoxelNode_MakeColorInt,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_MakeColorInt.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_MakeColorInt_NoRegister()
{
	return UVoxelNode_MakeColorInt::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_MakeColorInt_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Color" },
		{ "Comment", "// Make a color from its 4 integer RGBA components\n" },
		{ "DisplayName", "Make Color Int" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Make a color from its 4 integer RGBA components" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_MakeColorInt>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_MakeColorInt_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_MakeColorInt_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_MakeColorInt_Statics::ClassParams = {
	&UVoxelNode_MakeColorInt::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_MakeColorInt_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_MakeColorInt_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_MakeColorInt()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_MakeColorInt.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_MakeColorInt.OuterSingleton, Z_Construct_UClass_UVoxelNode_MakeColorInt_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_MakeColorInt.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_MakeColorInt);
UVoxelNode_MakeColorInt::~UVoxelNode_MakeColorInt() {}
// ********** End Class UVoxelNode_MakeColorInt ****************************************************

// ********** Begin Class UVoxelNode_MakeColorFloat ************************************************
void UVoxelNode_MakeColorFloat::StaticRegisterNativesUVoxelNode_MakeColorFloat()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_MakeColorFloat;
UClass* UVoxelNode_MakeColorFloat::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_MakeColorFloat;
	if (!Z_Registration_Info_UClass_UVoxelNode_MakeColorFloat.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_MakeColorFloat"),
			Z_Registration_Info_UClass_UVoxelNode_MakeColorFloat.InnerSingleton,
			StaticRegisterNativesUVoxelNode_MakeColorFloat,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_MakeColorFloat.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_MakeColorFloat_NoRegister()
{
	return UVoxelNode_MakeColorFloat::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_MakeColorFloat_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Color" },
		{ "Comment", "// Make a color into its 4 RGBA components as floats between 0 and 1\n" },
		{ "DisplayName", "Make Color" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Make a color into its 4 RGBA components as floats between 0 and 1" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_MakeColorFloat>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_MakeColorFloat_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_MakeColorFloat_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_MakeColorFloat_Statics::ClassParams = {
	&UVoxelNode_MakeColorFloat::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_MakeColorFloat_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_MakeColorFloat_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_MakeColorFloat()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_MakeColorFloat.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_MakeColorFloat.OuterSingleton, Z_Construct_UClass_UVoxelNode_MakeColorFloat_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_MakeColorFloat.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_MakeColorFloat);
UVoxelNode_MakeColorFloat::~UVoxelNode_MakeColorFloat() {}
// ********** End Class UVoxelNode_MakeColorFloat **************************************************

// ********** Begin Class UVoxelNode_RGBToHSV ******************************************************
void UVoxelNode_RGBToHSV::StaticRegisterNativesUVoxelNode_RGBToHSV()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_RGBToHSV;
UClass* UVoxelNode_RGBToHSV::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_RGBToHSV;
	if (!Z_Registration_Info_UClass_UVoxelNode_RGBToHSV.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_RGBToHSV"),
			Z_Registration_Info_UClass_UVoxelNode_RGBToHSV.InnerSingleton,
			StaticRegisterNativesUVoxelNode_RGBToHSV,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_RGBToHSV.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_RGBToHSV_NoRegister()
{
	return UVoxelNode_RGBToHSV::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_RGBToHSV_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Color" },
		{ "Comment", "// Convert a color in RGB space to HSV\n" },
		{ "DisplayName", "RGB to HSV" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Convert a color in RGB space to HSV" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_RGBToHSV>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_RGBToHSV_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_RGBToHSV_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_RGBToHSV_Statics::ClassParams = {
	&UVoxelNode_RGBToHSV::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_RGBToHSV_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_RGBToHSV_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_RGBToHSV()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_RGBToHSV.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_RGBToHSV.OuterSingleton, Z_Construct_UClass_UVoxelNode_RGBToHSV_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_RGBToHSV.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_RGBToHSV);
UVoxelNode_RGBToHSV::~UVoxelNode_RGBToHSV() {}
// ********** End Class UVoxelNode_RGBToHSV ********************************************************

// ********** Begin Class UVoxelNode_HSVToRGB ******************************************************
void UVoxelNode_HSVToRGB::StaticRegisterNativesUVoxelNode_HSVToRGB()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_HSVToRGB;
UClass* UVoxelNode_HSVToRGB::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_HSVToRGB;
	if (!Z_Registration_Info_UClass_UVoxelNode_HSVToRGB.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_HSVToRGB"),
			Z_Registration_Info_UClass_UVoxelNode_HSVToRGB.InnerSingleton,
			StaticRegisterNativesUVoxelNode_HSVToRGB,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_HSVToRGB.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_HSVToRGB_NoRegister()
{
	return UVoxelNode_HSVToRGB::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_HSVToRGB_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Color" },
		{ "Comment", "// Convert a color in HSV space to RGB\n" },
		{ "DisplayName", "HSV to RGB" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Convert a color in HSV space to RGB" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_HSVToRGB>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_HSVToRGB_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_HSVToRGB_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_HSVToRGB_Statics::ClassParams = {
	&UVoxelNode_HSVToRGB::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_HSVToRGB_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_HSVToRGB_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_HSVToRGB()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_HSVToRGB.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_HSVToRGB.OuterSingleton, Z_Construct_UClass_UVoxelNode_HSVToRGB_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_HSVToRGB.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_HSVToRGB);
UVoxelNode_HSVToRGB::~UVoxelNode_HSVToRGB() {}
// ********** End Class UVoxelNode_HSVToRGB ********************************************************

// ********** Begin Class UVoxelNode_InverseTransformPositionXZ ************************************
void UVoxelNode_InverseTransformPositionXZ::StaticRegisterNativesUVoxelNode_InverseTransformPositionXZ()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_InverseTransformPositionXZ;
UClass* UVoxelNode_InverseTransformPositionXZ::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_InverseTransformPositionXZ;
	if (!Z_Registration_Info_UClass_UVoxelNode_InverseTransformPositionXZ.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_InverseTransformPositionXZ"),
			Z_Registration_Info_UClass_UVoxelNode_InverseTransformPositionXZ.InnerSingleton,
			StaticRegisterNativesUVoxelNode_InverseTransformPositionXZ,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_InverseTransformPositionXZ.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_InverseTransformPositionXZ_NoRegister()
{
	return UVoxelNode_InverseTransformPositionXZ::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_InverseTransformPositionXZ_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Transform a position to a new basis defined by X and Z vectors\n" },
		{ "DisplayName", "Inverse Transform Position XZ" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Transform a position to a new basis defined by X and Z vectors" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_InverseTransformPositionXZ>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_InverseTransformPositionXZ_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_InverseTransformPositionXZ_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_InverseTransformPositionXZ_Statics::ClassParams = {
	&UVoxelNode_InverseTransformPositionXZ::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_InverseTransformPositionXZ_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_InverseTransformPositionXZ_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_InverseTransformPositionXZ()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_InverseTransformPositionXZ.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_InverseTransformPositionXZ.OuterSingleton, Z_Construct_UClass_UVoxelNode_InverseTransformPositionXZ_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_InverseTransformPositionXZ.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_InverseTransformPositionXZ);
UVoxelNode_InverseTransformPositionXZ::~UVoxelNode_InverseTransformPositionXZ() {}
// ********** End Class UVoxelNode_InverseTransformPositionXZ **************************************

// ********** Begin Class UVoxelNode_Pi ************************************************************
void UVoxelNode_Pi::StaticRegisterNativesUVoxelNode_Pi()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_Pi;
UClass* UVoxelNode_Pi::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_Pi;
	if (!Z_Registration_Info_UClass_UVoxelNode_Pi.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_Pi"),
			Z_Registration_Info_UClass_UVoxelNode_Pi.InnerSingleton,
			StaticRegisterNativesUVoxelNode_Pi,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Pi.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_Pi_NoRegister()
{
	return UVoxelNode_Pi::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_Pi_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Constants" },
		{ "Comment", "// Pi = 3.1415926535897932384626433832795\n" },
		{ "DisplayName", "Pi" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Pi = 3.1415926535897932384626433832795" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_Pi>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_Pi_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Pi_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_Pi_Statics::ClassParams = {
	&UVoxelNode_Pi::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_Pi_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_Pi_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_Pi()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_Pi.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_Pi.OuterSingleton, Z_Construct_UClass_UVoxelNode_Pi_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_Pi.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_Pi);
UVoxelNode_Pi::~UVoxelNode_Pi() {}
// ********** End Class UVoxelNode_Pi **************************************************************

// ********** Begin Class UVoxelNode_NormalizeSum **************************************************
void UVoxelNode_NormalizeSum::StaticRegisterNativesUVoxelNode_NormalizeSum()
{
}
FClassRegistrationInfo Z_Registration_Info_UClass_UVoxelNode_NormalizeSum;
UClass* UVoxelNode_NormalizeSum::GetPrivateStaticClass()
{
	using TClass = UVoxelNode_NormalizeSum;
	if (!Z_Registration_Info_UClass_UVoxelNode_NormalizeSum.InnerSingleton)
	{
		GetPrivateStaticClassBody(
			StaticPackage(),
			TEXT("VoxelNode_NormalizeSum"),
			Z_Registration_Info_UClass_UVoxelNode_NormalizeSum.InnerSingleton,
			StaticRegisterNativesUVoxelNode_NormalizeSum,
			sizeof(TClass),
			alignof(TClass),
			TClass::StaticClassFlags,
			TClass::StaticClassCastFlags(),
			TClass::StaticConfigName(),
			(UClass::ClassConstructorType)InternalConstructor<TClass>,
			(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>,
			UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass),
			&TClass::Super::StaticClass,
			&TClass::WithinClass::StaticClass
		);
	}
	return Z_Registration_Info_UClass_UVoxelNode_NormalizeSum.InnerSingleton;
}
UClass* Z_Construct_UClass_UVoxelNode_NormalizeSum_NoRegister()
{
	return UVoxelNode_NormalizeSum::GetPrivateStaticClass();
}
struct Z_Construct_UClass_UVoxelNode_NormalizeSum_Statics
{
#if WITH_METADATA
	static constexpr UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
		{ "Category", "Math|Float" },
		{ "Comment", "// Normalize an arbitrary number of values so that their sum is 1.\n// Not the same as normalizing a vector!\n// Only works on positive values\n" },
		{ "DisplayName", "Normalize Sum" },
		{ "HideCategories", "Object" },
		{ "IncludePath", "VoxelNodes/VoxelMathNodes.h" },
		{ "ModuleRelativePath", "Public/VoxelNodes/VoxelMathNodes.h" },
		{ "ToolTip", "Normalize an arbitrary number of values so that their sum is 1.\nNot the same as normalizing a vector!\nOnly works on positive values" },
	};
#endif // WITH_METADATA
	static UObject* (*const DependentSingletons[])();
	static constexpr FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
		TCppClassTypeTraits<UVoxelNode_NormalizeSum>::IsAbstract,
	};
	static const UECodeGen_Private::FClassParams ClassParams;
};
UObject* (*const Z_Construct_UClass_UVoxelNode_NormalizeSum_Statics::DependentSingletons[])() = {
	(UObject* (*)())Z_Construct_UClass_UVoxelPureNode,
	(UObject* (*)())Z_Construct_UPackage__Script_VoxelGraph,
};
static_assert(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_NormalizeSum_Statics::DependentSingletons) < 16);
const UECodeGen_Private::FClassParams Z_Construct_UClass_UVoxelNode_NormalizeSum_Statics::ClassParams = {
	&UVoxelNode_NormalizeSum::StaticClass,
	nullptr,
	&StaticCppClassTypeInfo,
	DependentSingletons,
	nullptr,
	nullptr,
	nullptr,
	UE_ARRAY_COUNT(DependentSingletons),
	0,
	0,
	0,
	0x001010A0u,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UClass_UVoxelNode_NormalizeSum_Statics::Class_MetaDataParams), Z_Construct_UClass_UVoxelNode_NormalizeSum_Statics::Class_MetaDataParams)
};
UClass* Z_Construct_UClass_UVoxelNode_NormalizeSum()
{
	if (!Z_Registration_Info_UClass_UVoxelNode_NormalizeSum.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_UVoxelNode_NormalizeSum.OuterSingleton, Z_Construct_UClass_UVoxelNode_NormalizeSum_Statics::ClassParams);
	}
	return Z_Registration_Info_UClass_UVoxelNode_NormalizeSum.OuterSingleton;
}
DEFINE_VTABLE_PTR_HELPER_CTOR(UVoxelNode_NormalizeSum);
UVoxelNode_NormalizeSum::~UVoxelNode_NormalizeSum() {}
// ********** End Class UVoxelNode_NormalizeSum ****************************************************

// ********** Begin Registration *******************************************************************
struct Z_CompiledInDeferFile_FID_build_U5M_Sync_LocalBuilds_PluginTemp_HostProject_Plugins_VoxelPro_Source_VoxelGraph_Public_VoxelNodes_VoxelMathNodes_h__Script_VoxelGraph_Statics
{
	static constexpr FClassRegisterCompiledInInfo ClassInfo[] = {
		{ Z_Construct_UClass_UVoxelNode_FMax, UVoxelNode_FMax::StaticClass, TEXT("UVoxelNode_FMax"), &Z_Registration_Info_UClass_UVoxelNode_FMax, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_FMax), 3371177050U) },
		{ Z_Construct_UClass_UVoxelNode_FMin, UVoxelNode_FMin::StaticClass, TEXT("UVoxelNode_FMin"), &Z_Registration_Info_UClass_UVoxelNode_FMin, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_FMin), 2174871373U) },
		{ Z_Construct_UClass_UVoxelNode_IMax, UVoxelNode_IMax::StaticClass, TEXT("UVoxelNode_IMax"), &Z_Registration_Info_UClass_UVoxelNode_IMax, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_IMax), 2359609540U) },
		{ Z_Construct_UClass_UVoxelNode_IMin, UVoxelNode_IMin::StaticClass, TEXT("UVoxelNode_IMin"), &Z_Registration_Info_UClass_UVoxelNode_IMin, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_IMin), 4238367986U) },
		{ Z_Construct_UClass_UVoxelNode_FAdd, UVoxelNode_FAdd::StaticClass, TEXT("UVoxelNode_FAdd"), &Z_Registration_Info_UClass_UVoxelNode_FAdd, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_FAdd), 3579296971U) },
		{ Z_Construct_UClass_UVoxelNode_FMultiply, UVoxelNode_FMultiply::StaticClass, TEXT("UVoxelNode_FMultiply"), &Z_Registration_Info_UClass_UVoxelNode_FMultiply, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_FMultiply), 4227234434U) },
		{ Z_Construct_UClass_UVoxelNode_FSubstract, UVoxelNode_FSubstract::StaticClass, TEXT("UVoxelNode_FSubstract"), &Z_Registration_Info_UClass_UVoxelNode_FSubstract, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_FSubstract), 1771843409U) },
		{ Z_Construct_UClass_UVoxelNode_FDivide, UVoxelNode_FDivide::StaticClass, TEXT("UVoxelNode_FDivide"), &Z_Registration_Info_UClass_UVoxelNode_FDivide, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_FDivide), 634697378U) },
		{ Z_Construct_UClass_UVoxelNode_IAdd, UVoxelNode_IAdd::StaticClass, TEXT("UVoxelNode_IAdd"), &Z_Registration_Info_UClass_UVoxelNode_IAdd, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_IAdd), 135938101U) },
		{ Z_Construct_UClass_UVoxelNode_IMultiply, UVoxelNode_IMultiply::StaticClass, TEXT("UVoxelNode_IMultiply"), &Z_Registration_Info_UClass_UVoxelNode_IMultiply, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_IMultiply), 457383581U) },
		{ Z_Construct_UClass_UVoxelNode_ISubstract, UVoxelNode_ISubstract::StaticClass, TEXT("UVoxelNode_ISubstract"), &Z_Registration_Info_UClass_UVoxelNode_ISubstract, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_ISubstract), 2644567140U) },
		{ Z_Construct_UClass_UVoxelNode_IDivide, UVoxelNode_IDivide::StaticClass, TEXT("UVoxelNode_IDivide"), &Z_Registration_Info_UClass_UVoxelNode_IDivide, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_IDivide), 2706824786U) },
		{ Z_Construct_UClass_UVoxelNode_ILeftBitShift, UVoxelNode_ILeftBitShift::StaticClass, TEXT("UVoxelNode_ILeftBitShift"), &Z_Registration_Info_UClass_UVoxelNode_ILeftBitShift, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_ILeftBitShift), 3218426471U) },
		{ Z_Construct_UClass_UVoxelNode_IRightBitShift, UVoxelNode_IRightBitShift::StaticClass, TEXT("UVoxelNode_IRightBitShift"), &Z_Registration_Info_UClass_UVoxelNode_IRightBitShift, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_IRightBitShift), 3602944927U) },
		{ Z_Construct_UClass_UVoxelNode_FloatOfInt, UVoxelNode_FloatOfInt::StaticClass, TEXT("UVoxelNode_FloatOfInt"), &Z_Registration_Info_UClass_UVoxelNode_FloatOfInt, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_FloatOfInt), 486954314U) },
		{ Z_Construct_UClass_UVoxelNode_Round, UVoxelNode_Round::StaticClass, TEXT("UVoxelNode_Round"), &Z_Registration_Info_UClass_UVoxelNode_Round, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_Round), 2794741339U) },
		{ Z_Construct_UClass_UVoxelNode_Lerp, UVoxelNode_Lerp::StaticClass, TEXT("UVoxelNode_Lerp"), &Z_Registration_Info_UClass_UVoxelNode_Lerp, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_Lerp), 359582494U) },
		{ Z_Construct_UClass_UVoxelNode_SafeLerp, UVoxelNode_SafeLerp::StaticClass, TEXT("UVoxelNode_SafeLerp"), &Z_Registration_Info_UClass_UVoxelNode_SafeLerp, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_SafeLerp), 728119325U) },
		{ Z_Construct_UClass_UVoxelNode_SmoothStep, UVoxelNode_SmoothStep::StaticClass, TEXT("UVoxelNode_SmoothStep"), &Z_Registration_Info_UClass_UVoxelNode_SmoothStep, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_SmoothStep), 3722159906U) },
		{ Z_Construct_UClass_UVoxelNode_Clamp, UVoxelNode_Clamp::StaticClass, TEXT("UVoxelNode_Clamp"), &Z_Registration_Info_UClass_UVoxelNode_Clamp, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_Clamp), 3099836334U) },
		{ Z_Construct_UClass_UVoxelNode_BAnd, UVoxelNode_BAnd::StaticClass, TEXT("UVoxelNode_BAnd"), &Z_Registration_Info_UClass_UVoxelNode_BAnd, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_BAnd), 200016082U) },
		{ Z_Construct_UClass_UVoxelNode_BOr, UVoxelNode_BOr::StaticClass, TEXT("UVoxelNode_BOr"), &Z_Registration_Info_UClass_UVoxelNode_BOr, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_BOr), 1265968663U) },
		{ Z_Construct_UClass_UVoxelNode_BNot, UVoxelNode_BNot::StaticClass, TEXT("UVoxelNode_BNot"), &Z_Registration_Info_UClass_UVoxelNode_BNot, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_BNot), 2155987959U) },
		{ Z_Construct_UClass_UVoxelNode_SwitchInt, UVoxelNode_SwitchInt::StaticClass, TEXT("UVoxelNode_SwitchInt"), &Z_Registration_Info_UClass_UVoxelNode_SwitchInt, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_SwitchInt), 2537169147U) },
		{ Z_Construct_UClass_UVoxelNode_SwitchFloat, UVoxelNode_SwitchFloat::StaticClass, TEXT("UVoxelNode_SwitchFloat"), &Z_Registration_Info_UClass_UVoxelNode_SwitchFloat, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_SwitchFloat), 769230834U) },
		{ Z_Construct_UClass_UVoxelNode_SwitchColor, UVoxelNode_SwitchColor::StaticClass, TEXT("UVoxelNode_SwitchColor"), &Z_Registration_Info_UClass_UVoxelNode_SwitchColor, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_SwitchColor), 2573455224U) },
		{ Z_Construct_UClass_UVoxelNode_1MinusX, UVoxelNode_1MinusX::StaticClass, TEXT("UVoxelNode_1MinusX"), &Z_Registration_Info_UClass_UVoxelNode_1MinusX, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_1MinusX), 1499894234U) },
		{ Z_Construct_UClass_UVoxelNode_OneOverX, UVoxelNode_OneOverX::StaticClass, TEXT("UVoxelNode_OneOverX"), &Z_Registration_Info_UClass_UVoxelNode_OneOverX, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_OneOverX), 23471005U) },
		{ Z_Construct_UClass_UVoxelNode_MinusX, UVoxelNode_MinusX::StaticClass, TEXT("UVoxelNode_MinusX"), &Z_Registration_Info_UClass_UVoxelNode_MinusX, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_MinusX), 557016765U) },
		{ Z_Construct_UClass_UVoxelNode_Sqrt, UVoxelNode_Sqrt::StaticClass, TEXT("UVoxelNode_Sqrt"), &Z_Registration_Info_UClass_UVoxelNode_Sqrt, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_Sqrt), 595119837U) },
		{ Z_Construct_UClass_UVoxelNode_Pow, UVoxelNode_Pow::StaticClass, TEXT("UVoxelNode_Pow"), &Z_Registration_Info_UClass_UVoxelNode_Pow, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_Pow), 1176356034U) },
		{ Z_Construct_UClass_UVoxelNode_IMod, UVoxelNode_IMod::StaticClass, TEXT("UVoxelNode_IMod"), &Z_Registration_Info_UClass_UVoxelNode_IMod, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_IMod), 2563711127U) },
		{ Z_Construct_UClass_UVoxelNode_FMod, UVoxelNode_FMod::StaticClass, TEXT("UVoxelNode_FMod"), &Z_Registration_Info_UClass_UVoxelNode_FMod, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_FMod), 18010545U) },
		{ Z_Construct_UClass_UVoxelNode_FAbs, UVoxelNode_FAbs::StaticClass, TEXT("UVoxelNode_FAbs"), &Z_Registration_Info_UClass_UVoxelNode_FAbs, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_FAbs), 2192146038U) },
		{ Z_Construct_UClass_UVoxelNode_IAbs, UVoxelNode_IAbs::StaticClass, TEXT("UVoxelNode_IAbs"), &Z_Registration_Info_UClass_UVoxelNode_IAbs, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_IAbs), 2812036768U) },
		{ Z_Construct_UClass_UVoxelNode_Ceil, UVoxelNode_Ceil::StaticClass, TEXT("UVoxelNode_Ceil"), &Z_Registration_Info_UClass_UVoxelNode_Ceil, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_Ceil), 2567939962U) },
		{ Z_Construct_UClass_UVoxelNode_Floor, UVoxelNode_Floor::StaticClass, TEXT("UVoxelNode_Floor"), &Z_Registration_Info_UClass_UVoxelNode_Floor, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_Floor), 1297918577U) },
		{ Z_Construct_UClass_UVoxelNode_VectorLength, UVoxelNode_VectorLength::StaticClass, TEXT("UVoxelNode_VectorLength"), &Z_Registration_Info_UClass_UVoxelNode_VectorLength, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_VectorLength), 3761087934U) },
		{ Z_Construct_UClass_UVoxelNode_Fraction, UVoxelNode_Fraction::StaticClass, TEXT("UVoxelNode_Fraction"), &Z_Registration_Info_UClass_UVoxelNode_Fraction, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_Fraction), 2973277283U) },
		{ Z_Construct_UClass_UVoxelNode_FSign, UVoxelNode_FSign::StaticClass, TEXT("UVoxelNode_FSign"), &Z_Registration_Info_UClass_UVoxelNode_FSign, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_FSign), 3689761836U) },
		{ Z_Construct_UClass_UVoxelNode_ISign, UVoxelNode_ISign::StaticClass, TEXT("UVoxelNode_ISign"), &Z_Registration_Info_UClass_UVoxelNode_ISign, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_ISign), 4135745419U) },
		{ Z_Construct_UClass_UVoxelNode_InvSqrt, UVoxelNode_InvSqrt::StaticClass, TEXT("UVoxelNode_InvSqrt"), &Z_Registration_Info_UClass_UVoxelNode_InvSqrt, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_InvSqrt), 3727976319U) },
		{ Z_Construct_UClass_UVoxelNode_Loge, UVoxelNode_Loge::StaticClass, TEXT("UVoxelNode_Loge"), &Z_Registration_Info_UClass_UVoxelNode_Loge, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_Loge), 244220370U) },
		{ Z_Construct_UClass_UVoxelNode_Exp, UVoxelNode_Exp::StaticClass, TEXT("UVoxelNode_Exp"), &Z_Registration_Info_UClass_UVoxelNode_Exp, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_Exp), 127605193U) },
		{ Z_Construct_UClass_UVoxelNode_Sin, UVoxelNode_Sin::StaticClass, TEXT("UVoxelNode_Sin"), &Z_Registration_Info_UClass_UVoxelNode_Sin, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_Sin), 3168561468U) },
		{ Z_Construct_UClass_UVoxelNode_Asin, UVoxelNode_Asin::StaticClass, TEXT("UVoxelNode_Asin"), &Z_Registration_Info_UClass_UVoxelNode_Asin, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_Asin), 3011487751U) },
		{ Z_Construct_UClass_UVoxelNode_Sinh, UVoxelNode_Sinh::StaticClass, TEXT("UVoxelNode_Sinh"), &Z_Registration_Info_UClass_UVoxelNode_Sinh, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_Sinh), 281876576U) },
		{ Z_Construct_UClass_UVoxelNode_Cos, UVoxelNode_Cos::StaticClass, TEXT("UVoxelNode_Cos"), &Z_Registration_Info_UClass_UVoxelNode_Cos, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_Cos), 4136296702U) },
		{ Z_Construct_UClass_UVoxelNode_Acos, UVoxelNode_Acos::StaticClass, TEXT("UVoxelNode_Acos"), &Z_Registration_Info_UClass_UVoxelNode_Acos, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_Acos), 2710883788U) },
		{ Z_Construct_UClass_UVoxelNode_SinCos, UVoxelNode_SinCos::StaticClass, TEXT("UVoxelNode_SinCos"), &Z_Registration_Info_UClass_UVoxelNode_SinCos, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_SinCos), 790443951U) },
		{ Z_Construct_UClass_UVoxelNode_Tan, UVoxelNode_Tan::StaticClass, TEXT("UVoxelNode_Tan"), &Z_Registration_Info_UClass_UVoxelNode_Tan, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_Tan), 1352472632U) },
		{ Z_Construct_UClass_UVoxelNode_Atan, UVoxelNode_Atan::StaticClass, TEXT("UVoxelNode_Atan"), &Z_Registration_Info_UClass_UVoxelNode_Atan, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_Atan), 2588163530U) },
		{ Z_Construct_UClass_UVoxelNode_Atan2, UVoxelNode_Atan2::StaticClass, TEXT("UVoxelNode_Atan2"), &Z_Registration_Info_UClass_UVoxelNode_Atan2, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_Atan2), 141452706U) },
		{ Z_Construct_UClass_UVoxelNode_VectorRotateAngleAxis, UVoxelNode_VectorRotateAngleAxis::StaticClass, TEXT("UVoxelNode_VectorRotateAngleAxis"), &Z_Registration_Info_UClass_UVoxelNode_VectorRotateAngleAxis, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_VectorRotateAngleAxis), 402255918U) },
		{ Z_Construct_UClass_UVoxelNode_BreakColorInt, UVoxelNode_BreakColorInt::StaticClass, TEXT("UVoxelNode_BreakColorInt"), &Z_Registration_Info_UClass_UVoxelNode_BreakColorInt, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_BreakColorInt), 1793433098U) },
		{ Z_Construct_UClass_UVoxelNode_BreakColorFloat, UVoxelNode_BreakColorFloat::StaticClass, TEXT("UVoxelNode_BreakColorFloat"), &Z_Registration_Info_UClass_UVoxelNode_BreakColorFloat, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_BreakColorFloat), 4121321902U) },
		{ Z_Construct_UClass_UVoxelNode_MakeColorInt, UVoxelNode_MakeColorInt::StaticClass, TEXT("UVoxelNode_MakeColorInt"), &Z_Registration_Info_UClass_UVoxelNode_MakeColorInt, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_MakeColorInt), 241019861U) },
		{ Z_Construct_UClass_UVoxelNode_MakeColorFloat, UVoxelNode_MakeColorFloat::StaticClass, TEXT("UVoxelNode_MakeColorFloat"), &Z_Registration_Info_UClass_UVoxelNode_MakeColorFloat, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_MakeColorFloat), 1777769704U) },
		{ Z_Construct_UClass_UVoxelNode_RGBToHSV, UVoxelNode_RGBToHSV::StaticClass, TEXT("UVoxelNode_RGBToHSV"), &Z_Registration_Info_UClass_UVoxelNode_RGBToHSV, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_RGBToHSV), 1644019203U) },
		{ Z_Construct_UClass_UVoxelNode_HSVToRGB, UVoxelNode_HSVToRGB::StaticClass, TEXT("UVoxelNode_HSVToRGB"), &Z_Registration_Info_UClass_UVoxelNode_HSVToRGB, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_HSVToRGB), 1209520642U) },
		{ Z_Construct_UClass_UVoxelNode_InverseTransformPositionXZ, UVoxelNode_InverseTransformPositionXZ::StaticClass, TEXT("UVoxelNode_InverseTransformPositionXZ"), &Z_Registration_Info_UClass_UVoxelNode_InverseTransformPositionXZ, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_InverseTransformPositionXZ), 2175968950U) },
		{ Z_Construct_UClass_UVoxelNode_Pi, UVoxelNode_Pi::StaticClass, TEXT("UVoxelNode_Pi"), &Z_Registration_Info_UClass_UVoxelNode_Pi, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_Pi), 1664157960U) },
		{ Z_Construct_UClass_UVoxelNode_NormalizeSum, UVoxelNode_NormalizeSum::StaticClass, TEXT("UVoxelNode_NormalizeSum"), &Z_Registration_Info_UClass_UVoxelNode_NormalizeSum, CONSTRUCT_RELOAD_VERSION_INFO(FClassReloadVersionInfo, sizeof(UVoxelNode_NormalizeSum), 3912907649U) },
	};
};
static FRegisterCompiledInInfo Z_CompiledInDeferFile_FID_build_U5M_Sync_LocalBuilds_PluginTemp_HostProject_Plugins_VoxelPro_Source_VoxelGraph_Public_VoxelNodes_VoxelMathNodes_h__Script_VoxelGraph_1743906224(TEXT("/Script/VoxelGraph"),
	Z_CompiledInDeferFile_FID_build_U5M_Sync_LocalBuilds_PluginTemp_HostProject_Plugins_VoxelPro_Source_VoxelGraph_Public_VoxelNodes_VoxelMathNodes_h__Script_VoxelGraph_Statics::ClassInfo, UE_ARRAY_COUNT(Z_CompiledInDeferFile_FID_build_U5M_Sync_LocalBuilds_PluginTemp_HostProject_Plugins_VoxelPro_Source_VoxelGraph_Public_VoxelNodes_VoxelMathNodes_h__Script_VoxelGraph_Statics::ClassInfo),
	nullptr, 0,
	nullptr, 0);
// ********** End Registration *********************************************************************

PRAGMA_ENABLE_DEPRECATION_WARNINGS
